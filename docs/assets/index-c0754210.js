var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
class EventEmitter {
  constructor() {
    __publicField(this, "subs", /* @__PURE__ */ new Map());
  }
  emit(topic, value) {
    const listeners = this.subs.get(topic);
    const allTopicsListeners = this.subs.get("*");
    if (allTopicsListeners) {
      allTopicsListeners.forEach((fn) => {
        fn(value);
      });
    }
    if (listeners) {
      listeners.forEach((fn) => {
        fn(value);
      });
    }
  }
  subscribe(topic, fn) {
    if (!this.subs.get(topic)) {
      this.subs.set(topic, []);
    }
    this.subs.get(topic).push(fn);
    return () => {
      this.subs.set(topic, this.subs.get(topic).filter((f) => f !== fn));
    };
  }
  once(topic, fn) {
    const unsubscribe = this.subscribe(topic, (data) => {
      fn(data);
      unsubscribe();
    });
    return unsubscribe;
  }
}
class Entity {
  constructor() {
    __publicField(this, "emitter", new EventEmitter());
    __publicField(this, "name", "");
    __publicField(this, "components", {});
    __publicField(this, "entityManager");
  }
  getName() {
    return this.name;
  }
  setName(name) {
    this.name = name;
  }
  getEntityManager() {
    return this.entityManager;
  }
  setEntityManager(entityManager) {
    this.entityManager = entityManager;
  }
  initEntity() {
    for (const componentName in this.components) {
      this.components[componentName].initEntity();
    }
  }
  addComponent(c) {
    c.setParent(this);
    this.components[c.constructor.name] = c;
    c.init();
    console.log("addComponent");
    console.log(c);
  }
  getComponentByName(name) {
    return this.components[name];
  }
  destroy() {
    for (const componentName in this.components) {
      this.components[componentName].destroy();
    }
  }
  update(timeElapsed) {
    for (const componentName in this.components) {
      this.components[componentName].update(timeElapsed);
    }
  }
}
class Component {
  constructor() {
    __publicField(this, "parent");
  }
  setParent(parent) {
    this.parent = parent;
  }
  init() {
  }
  destroy() {
  }
  initEntity() {
  }
  update(timeElapsed) {
  }
}
class NetworkController extends Component {
}
class UIController extends Component {
  destroy() {
  }
  init() {
  }
  initEntity() {
  }
  update(timeElapsed) {
  }
}
const GAME_EVENTS = {
  KILLED_EVENT: "KILLED_EVENT"
};
class EntityManager {
  constructor(scene) {
    __publicField(this, "emitter", new EventEmitter());
    __publicField(this, "ids", 0);
    __publicField(this, "entitiesMap", {});
    __publicField(this, "entities", []);
    __publicField(this, "lastSortTime", 0);
    __publicField(this, "sortIntervalSEC", 10);
    __publicField(this, "timePassed", 0);
    this.scene = scene;
  }
  addToScene(drawableEntity) {
    this.scene.entities.push(drawableEntity);
  }
  generateName() {
    this.ids += 1;
    return "__name__" + this.ids;
  }
  addEntity(entity, entityName) {
    if (!entityName) {
      entityName = this.generateName();
    }
    this.entitiesMap[entityName] = entity;
    this.entities.push(entity);
    entity.setEntityManager(this);
    entity.setName(entityName);
    entity.initEntity();
    entity.emitter.subscribe(GAME_EVENTS.KILLED_EVENT, (data) => {
      this.emitter.emit(GAME_EVENTS.KILLED_EVENT, data);
    });
  }
  removeEntity(entity) {
    Object.entries(this.entitiesMap).forEach(([key, value]) => {
      if (value === entity) {
        delete this.entitiesMap[key];
        this.scene.entities = this.scene.entities.filter((e) => e !== entity);
      }
    });
  }
  removeEntityByName(name) {
    const entity = this.getEntityByName(name);
    if (entity) {
      delete this.entitiesMap[name];
      this.scene.entities = this.scene.entities.filter((e) => e !== entity);
    }
  }
  getEntityByName(name) {
    return this.entitiesMap[name];
  }
  filterEntities(callback) {
    return this.entities.filter(callback);
  }
  update(timeElapsed) {
    this.lastSortTime += timeElapsed;
    this.timePassed += timeElapsed;
    if (this.lastSortTime >= 1e3 / this.sortIntervalSEC) {
      this.lastSortTime = 0;
      this.scene.entities.sort((a, b) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const pos1 = (_e = (_d = (_c = (_b = (_a = a == null ? void 0 : a.getGameObject) == null ? void 0 : _a.call(a)) == null ? void 0 : _b.getBox) == null ? void 0 : _c.call(_b)) == null ? void 0 : _d.getTopLeft) == null ? void 0 : _e.call(_d);
        const pos2 = (_j = (_i = (_h = (_g = (_f = b == null ? void 0 : b.getGameObject) == null ? void 0 : _f.call(b)) == null ? void 0 : _g.getBox) == null ? void 0 : _h.call(_g)) == null ? void 0 : _i.getTopLeft) == null ? void 0 : _j.call(_i);
        if (!pos1 || !pos2) {
          return 0;
        }
        return pos1.y - pos2.y;
      });
    }
    for (let i = 0; i < this.entities.length; ++i) {
      const entity = this.entities[i];
      entity.update(timeElapsed);
    }
  }
}
const adventurerIdle00 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADDklEQVRYhe2XX0hTURzHP5PEVl3GxDkCFUFEUFoqasEqQmNR1Eti4kMRyHzpRXuL/lnQSwT1EgQRRRHhQh+DEouIwlzQ2lhlJdQ0ZCw3xp2JKd4e1r3cqRS4c+wP+8Dlnnvuub/f+d7f+f3OvZAjR44cOf4AFlmGX1w5o5mvtxw9K80XSBTS7WnQ3LXVAKhxlZo6FyBPkBSj3Z4GzVVWSjAyjlmMUqgA0HbhlnC/eaINArjKSo2zGleNfnNbNFKEBCPjGe1ngTdL+kUjRcjlhy8twcg4SqFC1x0/z5u9uLc5eN7sNUSJRkqO9Lvd2tP1swCcPtWVca9we9e/kez3Wlo0gIlEghK7HQDXoQoAgrfHcBWVU9V3XbjfNSKNjbZ3asGvn5hIJABwFZUDaQGyEfZmdBGj7l1MxqLsfB8yBO2trDPG3f/wiul9bZw8d1xoVIQYG23v1PQJAoYQHV0QQJnVytuWfQBCxUipWvGpCBOJBOVXHwBQYrcbR9nNJ0zGosJ9Zp0ji6MRfuen6eMnNpw4TyA4yJd1KuGCdLJ7Og4TCA4Sn4pk63YJWYXWnNwft+wA0tGompnAZs0HIDkzZwipmR3DZs1nBCfHzvtorFzzdywtXcS2vhGOHLtI7a7d3PUNWCAtQKfY4aTY4TSum9u9APg/zGsIQkqO6OjR2GgSsRhRYlYsRN/4fkW4oILN1enP940OJ+GCCnp8zyze1j2WQHBwpa6XJauImMuqeWI2a76RI5OxqHEUO5z07m9aWO6ZbBGys+sTetR3DYDkzJwGUMMYNlOFMueNPlY/Z8uKhbQNDVku1ddrANHXgSV7Q39MX3nfM/pbHelCddc3YOk4eEBYskv5Et20tXFBURRUNfNHSu8LDfuFFxkpVUtRFKMdGvbnmSduvicSqeV3NZEixLM2RdV8NGMJhYb9eaqq4lmbkuFSvJDe/U0Ltp8/VItpsH4zxoj2K1yILsJVWiLa9C+RliM9tx4ssX3jcTjvc2paij8pQpKmHX+1EC4kmUjwu7f+OTUtJU/+C34AdKI8D9icPRkAAAAASUVORK5CYII=";
const adventurerIdle01 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADH0lEQVRYhe2XUUhTURjHf7OibnQZmw0bzSU0EYpWglloQSwSinqK2KsgC6KX7C2QrAiCCIIoKHpIjIgUe4pIjKJASQa2JprLApsTGcuNdbVFym4Psdu9jAraOUWxP4yd++2733+/e853uAfKKqussv4l2WQVHr7WqZuvdxw/K80LJIKcaGnQm7dtAkBLa2yu9wPygKQUPdHSoPu91UTj05hhVKcKwJGL3cJ9K0QXBPB7q41vLa0ZcfNYtKSAROPTlvFgZLwoLlpSQHYvrCQan0Z1qhy9E2YoEKJ5l4uhQMiAEi0pIPFcDoDByDjrJm7yqNmGa2MDj5ptHHNslWHJcilVgQ0f8hyorSd1dRj2LwMgevsd/rU1UvyE7x6xYJt+xaniG35uxA7U1hvjh5MvaR8ZEe4rtGAs2Kb31vmYTSXZ82bUiCcyGWPsVRRe7z1Ix7lTQr2F9UgBAsDtqiJR+Zma6/0AeBwO4+PtegbA+dMX9B8W+w1J65E1wQ4i0QFmVmvEFA8AgWCISHSA2VQSt6tKqJ8wkMJsjE2EqcslmH/QCz7FkjPT1YldWUEasRAgePudTSW/X5ggnJVenJVeS27ryUsircWAxIJt+mwqSXouTuPbKewzS2Rzi2Rzi8QUD25XlWUpBYIhAMKTS8L6RAjIx/M3aD15yfiD2fXfVmxM8VhmIuVpor1n0AYQiQ6IsDZUMkgs2Fb0VGOKB/vMEs5Kr2Um3K4qzhxqzIcO7ze2XlGzUnKzRz9MUWO6bh8ZsV32KTo+hfRcvCjfVarhDyRs1zIvlWxuUQeoI4F9LmmOF92zzb9PiL8QkALEk3s3jVhfqrBivlhyD7tsllzzPaWo5B5JZDIkX0WIPO43Yn0pHVVVi3JVVTUA7/bcF/qKIuWo27QvkAfQNI3RF+EKgC07t+cLcEMDT4QfH6ScR/6GyiA/0xH3CsuyAhh9Ea7QNI2WVfMyLMWDnDnUmAdoUD4V/VaIFXJESjiI3eEAwF/tEV36p5LWI+3d/UW1bz0dq3g/vyDFTwpI1nS0/VMSDpLNZPjVU38/vyClT/4LfQWO/xrYngYqPwAAAABJRU5ErkJggg==";
const adventurerIdle02 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADL0lEQVRYhe2XUUhTURjHfzMjF4wxbZikQ8hYJK2UWcEKwpVR1ENFSQ9FEAuilwx6CAIzeoqgpyCQSIwIlXqMpCgKDGtgNrFaEtScyJjuMu5skeLtwe71XhcE3XOKwj9c7jnf5Xzf97vnfOfcC4ta1KIW9S/JIcvxy+utmrm/+XSbtFggEeRMU1ALbVwHgJpRqa0LAPKApDg90xTUAr4qYolRzDCuUhcAh650Co9bJNohQMBXZdzVjGrYzW3RkgISS4xa2n2DbwvsoiUFZNvUMmKJUVylLk7eifKiMUJoq5cXjREDSrSkgCTyeQD6Bt+y8n07D0MOvKuDPAw5OOXZICOk+GLvCYe1pKIAsGdN3Zxx9xIAYrc/ElhRjb/rpvC4Qh32hMNaPLSD8XSKmpfPDbsBBDwYec3U3kNcuHReaGxhzuLNJ7Qef43R9/c9Ntr6DAH4nE7ehfcCCIWRUiPj6RTJsq9U3+gFoNLjMS5fxzPG0ynhMYW8EfNsDL+P4s8nWXW8DYCxjlbizkoAGpsjADzpaqe0zEeFt1zYrAgFGU+n2P5hiOHlKu6xGahxks1PGyD+fBK3cymvKKexOcLGwE4AGtYU287D9tIyQ2QmEyQVxYAwq7TMZ7Tvdt93AAzGHtkNb8g2SGziE7uOnuP42avG0smuKp67/5iN2rUNVHjLLeMiB3cbsxAdmbF8Kf+ObIHEm08UJNAyMOAAK4Su4rr9tHT3SflQlbJrxZ2VuMdmLMtJ18V9m2bNfVHLq9jO4NjEJ5KKQvWChDaRghonmclEwRivqf2kq91ytyNbILp0CD2hbH5aA/CTxD05f2Zk89OWcXe77zuOHD5guz7AJkhSUWgZGHBcfjOoLTzk7qX1/L5Z7Ae91hLRdzC7EuLkWn29BvOFvn5Lw6zL5UJVrT9Sum2oPyq8NoU51CFgLmFdQ/3RInPi5mciJQTEDPG3JGX7/RuSAtJUkiuohaH+aJGqqjSV5GSEFA9y7diuWbfHQ9D5peCZblt4KIqQtKUVqKqU5fqnkgbS0tlb4PvW0+Giz7kpKfGkgGRNv7Z/SsJBsorCr97659yUlDr5L/QdBKs3h1tmkOAAAAAASUVORK5CYII=";
const adventurerIdle03 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAAC+UlEQVRYhe2XUUhTURiAvy2lFlxEUypQE1ImCStF18MKYgtF0SeRPdWLLIheLOghELKgl16EKAh8KIweTHwKRDGNHhR1D647spYFNhci08m42gLD24Pcy5bTyp2TEPtg7N5z7v3/8537n8O9kCVLlixZ9gGLrMBTj27ryednr92RlgskinTU1+quM6cA0GIaVdUOQJ6QlKAd9bW6o7QENbxAsoxSoADQdr9XeF6r6IAAjtIS81+LaWZ78rFopIio4YWU4/HA7LZ20UgROb9+EDW8gFKgcOW5nwm3D9e5IibcPlNKNFJEwokEAOOBWY596GHIZaHoZC1DLgtX80/LSEmOlKjAieVNmiqqiT6cgsYDAKjPPuMoLJOST+juEfK26wAPChQufAwSWV0FoKmi2rxmcG6G9eY2Ou/eEppbWLCQt11Xl+cJuS4CYB9/ZfYZQgClNhvvPc0AQmWErJFfJQAiR75T9ngYgOL8fPNX+vQNi9ElEWlTELZGDInF6BKxlTBubycBdYSvhzVCtmIA3F4fAXWE2EpYVFqTjB9tyNuu99vLzVmOrYRxfpqHchsA8cSGKWJPRMiz5TLNUW7cewFAXUWOkPLK6In0ezw6QMOlmwAE1BF8rY0We4tTz9vlPrfXl0natOx5jfR7PLqjsIzBuZm0/fHEhvk0qirrqKqsM/t8rY2WgDoCgH/uh542wF+S0WLfScLAkDDIs+UST2zokCojgj2VllFSsLUjGQMa6+sBtgZskLJDHamjKDJhno719Zj3ZMqe10jb6KgFoLumRl9/G0gZsDHrdiLkraS0732kv0HK90hXi3NzIJq+9FuLLHS9nBb+jiflpXEgqqMoyrZ2RVHYSTBTpIgkSwQn/dbgpN+ark8kUkT2g6zIbrQdz0XTNJJLKjjpt2qaRv2hNRkpxYt0X27YBKi1fdvWZ7R1tTg3ReeVVlqOkmJZodMiTeR67/C22E9ev7N+WVuXkk+KSDzpi/BfIVwkvrrKn8y6jHXyX/ATLKgWS5tcfVwAAAAASUVORK5CYII=";
const adventurerRun00 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAAC8UlEQVRYhe2WX0hTURyAP5ch5oZMNAn/9SSRtFTMQFNoombgSyG+CSUTzJcteon+WeGLPdhD0mOg9KL0FAhmqwgc2sBsUiAS1ByIzO02blpU3NvD2m2bK3X33lmwD8Y959yze37f+Z1zz4U0adKkSZMmeTJ2Y9DZ4RtydP14303VceyKiL2lRq6vPAyAGBSpqLIA6oRSLmJvqZEtpSV4vMtEy5jyTAB0DI4kFZNBuxC3h6W0RLmKQVFpjy4nQ8pFPN7lmPL0/LtN7cmQMpG+Xrvc12uXG9az8HiXMeWZ6HnoxmW1UX+iAJfVpkglQ0r2SF+vXQ4GvJwJhPAJAh/zw/N3/VpPTL+8hp6k48lUF+LWLHZ2ywRFPIGQ0la2JgHgvzcLbXsA8Iy+VzWObiKLnd0ywMTSa6UtVJSJv7xRqU/MvuQ0VQBY8g+qGk9zkXiBYrMZnyAQKvo91IGCQlb8qxSbzTGiatB8s3vWPsRIABivDCTs+6L8CMVms/JTg2YZGW9qkgF8gqAE5RMEHHNzGTid9LfXyvH/CQa8fLpwCQDb2TZVLx5Nl5ZPEBKWoyUKfC5WqCMY8HJxYEzp4176IQNMjt7h6q3LO5bSZGmNNzXJiSQcc3MxAeVm7wXCmbB22pj3TG161op/NakYNMlIh9OZMVRdHbN0oiUiAqEv3wGoOHSM1TfzFB6t3CQTDHiTikH3cwTAJZWGC1nhy/5fs77ydJLh+3c1OZR1P9n722ul6HokOxEcY9OaLO+UZOTJVyMAoigC32Lu1TVbJdfUM9Uyun80RiT+hCiK1DVbpb922ga6ikQHGM6GfqTkM14URfY1nmJhxm1YmHEbarI3qMneUO7/F0srkonZwdsGgHMnKySAMmMOAAsz7n97s/e310qP/GGJ+GDLjDn0P36l6STqkpGhrlYp12zmfHneJokHz9/qMqauS8sxMpnw+VpnQxeGulql+EMwFWg+MyFB4OPnda0fuyWai0QkIm+nNDvkJxA5GKMNOlV5AAAAAElFTkSuQmCC";
const adventurerRun01 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAACvElEQVRYhe2Yb0gTYRzHP5oR5UacuSSY2ovwRcORYisyIz3SDPfKhvRGlNAX9UZ73Z8FvqrAXiS9V3pho3ciaAgSKImgsiASEXIbiKxtxClZwa4X687NDazdcxvCPjB29zx3PN/P/fY8dzcoUKBAgQIFClCUj0EXRp6oyfuX7j81nCMvIgOtDWrjhfMAKFEFR50TMCaUc5GB1gbVWVWJPxAkWcZaZgXA82w0q0zF4iL+G86qSv1biSp6e/J2NuRcxB8IpmzPrXxOa8+GnIr4ZFlt2jmGPxDEWmal/80i8y19NF61Md/Sp0tlg+lzZLXrrgrg//aV2Zpazi18YKM8cf0eP+pPObasqT/rPCVGQmbCJ8uqs/ysvj+5toxdkpitqQVgp8ND9YQPgPCrBWg/AoB/bN3QuIZFfLKcck8IxWKEYjHskgSAXZIIxWIAnLFVsBne4vrfvsm1ZW5RB0CyfDYYFvHMzBT5ZFnVwgK6hNY2uLRUNNTh0YVDp3YTxyExubZsNAIg6Ke1XyJZYP+x0UgAS9fDxHnjQ9iRREQQO0cOktgMbwGwPT7E9x+/AbDcS0j1dbYbWniEiGihh+vr1UwCXrdL3Qxv0fPgRdq5U2PPKf0yYTiD0PtIJgmNaCSQsV2rklGEL7+ZOHn8KAAr/vdpfdFIgMG3c4fj6ddz+07KEn3aVqFvj7x+KSRDTiri+Lmuwl5liAT0yS4K00W8bld8eteCoijAr5Q+q9UqbBzTHxqndy1A5tCKonDlRktcxDimVcTrdsXfhfemRqIi5mFKRYa729Ku8olrN/n0cbFY+2jtogRNW7WGu9vi/mCI1ZIKFEUhObxG7eWLunCm/v/BtDkyODpVXG0pBQ4O2WnLy38gYultdsS9bpfhCZ/zd/b9aFUzSt5FNrZ38h1BHL3Njnhvs0PI/eTQ8wcvevgssbNBJQAAAABJRU5ErkJggg==";
const adventurerRun02 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAACzElEQVRYhe2WX0hTURzHPyvNVkpc/2TBFMnScLhUZkUSFCMrewop6aGoICGCcEFvpgSC0ENCEEUiRS8h4lvpw8B8UYrVkiuLkQipE7Olc1x1lrbbw9htziTZ7jYf7uflnnPuPef3+97f73fOAQ0NDQ0NDQ2NTYcuGUbfP26Ww/tHbt2P2Y+kCGmoNstVZSUASLMSxnITEJughAtpqDbLpvw8xPEJwsVkZGYAcOHBy6h82qKeixvDlJ+nPKVZSRkPb0dDwoWI4xOr2gNDn9eMR0NKTLOBLotFBjBlFyhjxZ0da9Kjy2KRnTskdk2uIBJMq/pWO1c7nnFzz0eefjsDfe1R+6FKjXRZLLLb61X6NQfKV70Xf3ylv6gUgBNfhhnY6gOg6V79qu8yj9cnt9jbKipkAIMgKGOm7AJ6Rj5hEAT6i0rZm5MLwE7Xawwz2wkJr7ltDk7o/f3PSG6UmFMrkvDIRIpwuuwcBtxZSxgQcHu99Dz6oIpdVYrd6nDorA6Hzu31YnU4dBAUFBJ1+vJdnC47xX436XWNpNc14s5aYnBfMQZBwCAIyrxoifs5Yh9ZWXWKv7lzTGk70wqpvnQFgBu1Z2PyJe7b75BoY0i0Kf1zDwdJKT+PM60QgMkXzcx3tmAfWZFbmlrl9db5H6rXSCShP93e3SsDlJlOMeWZ5lCJiSnPNLhHSa9rZEi04XTZo7YTdyEh5jtb8PmX6dO3YzxYCcB3zzT79akxpxUkUMhgIB/SgADBSAC7c3KxPnmlSp0mTIjx56i8S58a7MyM4/Mvq7p+woR0e2TgFxkZwVuuJP1tq0HCL43xImFCanN0mPWLSFJs1/X1iHtqtV2sCgCq10QkCYmI6JljbH4BQInK9fxtDNr6VLMf94iInjmev3UqDpcerQyY9Yv4/OrejuIekXARAMPv7HGxqe1asTI2v8C1k8ZAsuxvWv4A/8b379AZM7AAAAAASUVORK5CYII=";
const adventurerRun03 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADF0lEQVRYhe2WX0hTURzHP9NCrMaYNiWqJfRHSFwqtsIV1IaGkQ8VTXorYtKfF4Veoj9a2Es9+BQEEUQSMcVegkAMichRCbZuJNQY1Lwha9VaV5PQdntYd39SZGx3t4J9Xu6553DP+X7v7/c750CePHny5MmTOTqtF3x2rVNOft926qIqGjQ30t5UL9tqNgMgfZGoqrUA2RvS1Eh7U71sMa9FCEyQbEZfogfg0JXbGespUEdieljMa+NP6YsU709uZ4qmRoTAREp7xDs+rz9TNDVi+2lACEygL9HTdmcUj92FbYcJj90VN5UpmtVIv8MhA4wURgC4cL4tZbxkZ9u/XeynTrTLq0zlAEyGgmx49pi9G2tjg82FAAi9fiwrK6h038xYT06MjPrmZK8wRPClN943GQoCsOvtK8RwGCBhCHjge8H0vkOcu3QmI01LshG8EG9aj8nfgBpLI15g2H0DAHuriyl3N2IprMGIGA7zwPdCtXVVNyJ8ekdF0vuBzxFeL5P4cKuT1UcuAiC6u/EYKwFwhj8C8GhTNauyWFc1I0oxi+EwHN9DxfVBAO6VGqiciZ0TH251Jj4oij2+njwdazwcZDIUZNQ3F7/CDPZeTTvVVI2IkvsAT1qtrDh7mZJSM4giAIbipURmZnldtB6Aqh9+ptzdPCe2GdhbXXiFofgcSl2lgypG+h0OOdmE0nYdbNYB9DhtMkBkZpYltfvZoogU/XT0jegADjsPpFwmh903uNt3L+3CV23X6qmrSxHSMTYWn7vHaZMVEwovxwUaCgJxI9mierEvhCdqjtXEuEDZ7zOlzFRORPTLi3+ZPjk/ELtarNFFx+8/V+WapElEBkKJH6/X61PGGhrtUc/QcNZmcn5pTDYBIEnzr+wNjfZFo5YOOTVSvX3rggIlSVrQUDZokloKr56OFkCibgZCUkp/NuQsIn9GQxF7dHdVFMBgNKb0Z4smEUkWu27FcgxGIx23B1X9iTmJSFeLNXrQpKO++Pu8P67WdqsJXS3WqJJC/y1/y4TqYX4/Na32lGmRs3z971Prb/EL2goexu7AHIwAAAAASUVORK5CYII=";
const adventurerRun04 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAAC7klEQVRYhe2WXUhTYRiAHzOphUNmLhFURErD4VLRKWpSDg0FryK8i37Qi7ox6SawWpE3FXjVlUSQdGHiVWRE2M+FoxyoTSaWDmoOZJmucSwzaaeL085+pJCzs4PFnptzvp/te5/v/d5zDiRJkiRJkiRJSNF6wTd3roqR7erz11SJQXORruZKsa6sBABhRcBUbgbiF9JUpKu5UjTn5+H0LBApo8/UA3Di5n3F8exQJ8StYc7Pk6/CiiD3R94rRVMRp2ch6n5samZTv1I0Fan7mYHTs4A+U0/nAwf2xg7q6o3YGztkKaUkvEbetZ8VAZyfPwAwlhoA4Mrlzqh5mYc7t1exD1mtojmrQG6PzE0yX90AwJH303j9floPlEuDLakAOAfcmLMKKB68qziencpDlhiyWqPeC16/H6/fT67BAMB8dQM5xmxpbNlBLgZG5iYBaEUSMmcVyH1KUSUjQ1ar6PX75XZI4mVRKQA5xmxcsw4s+KTx5d1Ezge4MDERVyyqFHusRCgrAKe6b+OadVC85iW9vYf09h68e79jLyzGXlhMrsEQtwSocLQiCUmAtMOOwXERoLv3IQCPu2vDk3dJly/nLsLoaNxrq1rsfRUVYuTu9g8/EQHKzE3ynKcDt3g74wTAtO4mQ5dGfe8reazn+iVFMamakdgj0nG8JQWihRaXfBwqMbO45AOvm/T2HqaczwBwzToUr62qyJ9YHbxBYG2D57p+TAerAPi05GO/Lk2WjRdNROzBfKkmgkiZAPYZswl43eLff7l1NBExrUsBZ+jSYNkDQGBtQ9U1Ei5ia7MEh5dCG/8DAL1ej/zYUomEfzSGJcIIQvizvbapMajGOgnLSHQmNiMIwu/MqENCRGxtluDH1a/Anqj+6dcO+QSU1lQF1ZRJyNGyPRrfAVCp+yb3RUrEtktrquI+XgmrkXsvXPJ/x0pEIggCZ4oyExWGdtjaLMG+k8e2b0a05r8R2RacPmoK2tosqrxP/nl+AaTTDxGxkhmAAAAAAElFTkSuQmCC";
const adventurerRun05 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAACg0lEQVRYhe2WX0hTURzHP+ufGA256jJhDilikDRSVgaSLwMJoyepXqWHgQgxe+6PPQUVCEEQhQT2ICX1Ihhl2NOkXC25sQhKqLmoWNuUW6lluz3cdtuchu6e3flwPy/3/H733PP7ffn9zrkHLCwsLCwsLCzWHbZSBH127byabTd3XzCcR0mEBNq8asu+PQAoSYWGRg9gTJDpQgJtXtXjqkOOTpMtxl5pB+DYpYGCctogLsXV4XHV6U8lqej+7HEhmC5Ejk7njIOTr/P8hbDJ0NfAkM+nAniq63Wf+05/XnsM+XxqZKtCxcdFZLS28l8M0dl/g64dL7j++TCM3Sw4DyF7ZMjnU2OplG63727MeS9/fQ9ALJXCKUkEN84CcO6sP2de5SF/aTd7X1OTCuCUJN3nqa5n5O1LnJJELJXiXXMrALWOGtzBx2SEt5/yah88+L1sJVeL4dZaSnZlMiJ6wmFbd3OrWuuo0eZUzeNEezdy9bmQuEI2e084bOsJh22ZpEETlG1niLwJse3EGWJV84zvdOOUJJySlDdvrZj2H+nuCqgAyUQU91wMgEjZLhoWpugdnjCch/DW+h+dp6/k2EeAh7cvw/CE4bVN+48kE9Fl/Z/iX4Ssb2pFJuXRPN9KAteKaUIW02U8GhwAYPvf0wtg8O59IfvUNCENC1NqRflmzUhEmZ37JXR904Tci6vAT+x27ZarKP/GIjD90lgsTBPS4bDhLf+Bohi7rq9E0Vur73hLGhC+J5ZiSkXk+Awfvn0H0Kty0rWF8dExYfGLXhE5PsOtJxE94b0H96c7HOJvRkWvSLYIgFdPQ0WJWZJTK9NmIinZ8SvHZ+g9eiBdqvjrlj8Nvt5RZSRFTAAAAABJRU5ErkJggg==";
const adventurerAttack_1_00 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADmElEQVRYhe2XX2hbVRyAv3PT21G3UFOaVqGLga10WA3r6NpI3B6a2TLnhHZMUUF8mQ+KMMUXUdpaOgr6MHzwQfZgcUxYC5aik261E9q166xLQzClsgldWplrTZPsNunELceHkEtj/2a5eRDv95J7Dvec3++7+Z1zzwUTExMTExMTExOT/wsi3wGufd4mV7br3/44LzHzLnKysVZ69j4JgLaoUV3jAowXyqvIycZa6XLsJBCaZaWMtcQKwPFPvjIsvmLURGvhcuzUf7VFTe9feW0UeRUJhGYzrkf9U6v6jSIvIr1er+z1euUTfyYJhGaxllh589wEYw0n8DxrZ6zhhC5lFIaLdLZ2yV89hzL6Rv1TPDZ9hgGPwL6rlgGPoNR9zNC4hi72ztYueXvhDovhEFXLcxTUNLP9u16er6xJ3XDYAkDg7G+4Sp30Vu3mo44PDMnBkEk6W7skwO2FOwAshkNU79nP/ck+qhNW5iIRAF3o+xuT3Kw/CMDj9nJDZHKaYOLGfQlw8eynBKcnAGgJx5iLRNjx4SkAfu9uy5BJ89NuJ++d6tHb+ysLcsqlIJfBAP7AIMHpCepuzlBhswHwrs8n2rvbZHGRSnGRShCNoK2KlyLzABwfGhL4fDS8PCj3up7DHxjMNY3cF7v/h4sZ7blIhPajdbK4SCW2/DfxPS9QUNMMQPARjehb72eON0ACcvxH0kn8Nf8zFbZKvXzSEsFtu2AqQJm9nDJ7OQuU037ssF5Cl8+fySV8Bg9Vl99+sU8CfD3kBNDLKi3SU2qTcW3123u7NXU0uXppyPBtP+sJF8ZekXftAwSW3+FV7wwt4RiALnHeXiKFlChK5tRCCNJyzzR6k7km/m+yFrn0x2fMhC7gdBzhXo9t1W4kpCSRSABgsVhQVRVVVUkmkwghEDJ1qnc3HTJUJiuRc9/My5nQBQ64m3mtpWzNsryXSKQSFoLJK1eV68OjyvXhUaWwsBCAeDyOFIKmbcYeHLe8RobHo3JkvI8D7mYOuh/Vx53el1ov0QpV9ocFiqLgGxlb9wG90fBU0mHdgRQCKQSdfevfmw1bmmQ9CUi9M+TTZbLYZttUAqD78i9KR/+4MntX08vMCDbdfjeSADj9elMyEo0ipMQ3cm3LT1dIieXBg2zzXZcNRdISTseRNSXaXqxPRmIxOvrH8/pdsxU2TWCjhX1rKU5IW3qowF/+GFRuLcVpP1pn+Fb8n+YfA69rHvGUhs4AAAAASUVORK5CYII=";
const adventurerAttack_1_01 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADX0lEQVRYhe2XX2hbVRjAfyfbmEOipjOtY2062HSwP7GGshWjPnTaPQyFDftQxLGXCTqQ+uCTQp0WBnvZHE6QPjjFgZ3YKbK6tY3KNFlLAo2BbpNY6G4i1aVtEpPuD3T328Mld+m6mTS5VpD7e/ruuSfnfL/7nS+5ARsbGxsbGxsbGxsbm/8GtVQbjRzvkuLr7QcOWrr3kol0tjWLv2kTALmZHJuf8gLWCS2JSGdbs3g9DcS0BMUyzhonAO2HP686D0e1C5TiiM8nXk8DAF5PA7mZnHmvOK6W5ZatBBx4vVPWuOsA2BgcMseDWoKCTExLgGZIxbQE/ppNluxtSUXC8Tnp+fp7AZhM/QXAb/7n+emJrSTTaRqndGJaAmeNk9dOhgm17sf/jJtQ636C0YtWpGCNSDQ2SHTonHk9djlsxvUulxkHoxd57HIPZ/0K9/pmzvoVRwcilvRp1SLh+JwUJN6cybFh5DxgyKxx15FcfYN6l4vGKZ3GKZ3URyOkxiOkxiN8PDhd7fYmljX75KU+M94znWXb7xPUPdkEYMoA9MdH6T8Wof9YhJ2vvk04Pif3XHCRVNzs333iEzCO1eSlPg7VvUB/fNRMOLt2OdkTXazddxCAZG839Rj32gMBVeipaGywSgWDikRSoQ4Z+PNDJrQzeKfeoWPZ46ZEMp2GDavgujH3jxNdAIytXE/bG3uNwUAAsE4CKhQpSKzz7OLG8S9IptN3JO7i4VUrCOkeNt8cJ9/bzVunggrgh96eKlOfz6K/MU72XZUJ7QzPtuzmuZZH1Fc7dkhBpD0QUADtL3fc89wn/74qABcGApb/EC9K5PxwRn4ePj1PAphXiVOPuuT67Cwid1xEBKUUIsKDTuO1RJRi+NyQZUJlL3S3RGG8WOLL2tVyLZ83JZRSKKVwOBxmfC2fR5Ri50rrXk+gzB65n0QxmfoVcnPaSM7hMJ7P6C8XFjyoJn+L3vZAHl05eHf303r36ZAlVSl5tAoS6zy7eGVP7YL5R3w+ka21AvBZPM2voZGyEtvXukVveMjJB98slK2EsiryT5Vgi1symQxKpGwJACXCslu3yp1ekpIi9xUAul7arqezWd7/dvhf/ztQiqoSuJKfRcvlK/rspz+OOa7kZ3nvxW16NTn877gNsUlkkMLSJncAAAAASUVORK5CYII=";
const adventurerAttack_1_02 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADv0lEQVRYhd1ZW0gUURj+ZrGLxq66slqhW1RUVErRRcHsoe0iRIKCiAQWSD0XRBBdFBF6q6fooYd8MRHBza5QUaHssiboOrGWFbg7a+Z911YxapvTg83srHuZmZ1L0QfLMv+Z+c//ne//z5lzhsJfQLcrSJK1HyrJouT6lP1AqhALPhGkktKUSLcrSPxjP2LsBetXyvYlRsgg26MMxCPB2bmfVIgpqpkirZ2TslNJilKJlNGlRrpdQdLjsqOspFKyCslIxSOjaWoJOy4rqUSPyw4AOFWVKzqAyQjHSzPdZi0ugB6XHRutJ3gyYikoVRldFBF2XFZSCS/zBK2dk2TKWUvE1JGairoSAZbIbLSegGmqHA++1qHvUzhlMsIU050IEKmRtdNX4KZfKCLDIU3F+CSh93bD0iiGl67HAZ7Mx3ezSZ/1j/1IWDO6K9LW9QSMbwSMbwSeARpF4y6+bWuhWbY/Lr10VeT8sX2kyFoAh3sIpbt3wGg2wjNAI8s8AvefezKovSn51lWRImsB/x+aDfH2Tu88XrXfxcSgW9IaEw+6KkIzfp4MzfgBBpjIssKcY8U6Sx6uNl1OeV3TVZEN0yxoxg+j2YhzrX1wHj4Lc44VszOMYt+6Eemw2Uh+djYAwOEewtoPd7Hf9x6zMwx2bt+vSA1AByLN12+Q4Zp6AgBvthai9Fcmfm4+iGv3h1TtR/MaqR7+DHrai9FAALuPHMcbQRunxprHHYr70ZTIcE09efppIMomrIeqmTnA8RLV/f0ppxX34qjLrJWfnY3RQABfWhqwTWD3ZACNj95GkUj2NpzsTVizGuHU4AocW9Kj2j2rNsvyJ7Z71ITIcE09oae9/LUnY2nxy0xfwdtyLXkxz8ndHmu+H+GKm0spIQEASNtTicmpiRh7IkjZy6teIx02W9SoXujvp6o31UZsqwAM0ci15OHCnTZ+RBOpkYjE8n27qltdIYnRQADtFjMBAIoQLIRCUfdmmEwgBgN6nz03KCUBqKjIchIAsCgInqIoEBKJdzEUQrrRqFgJDqoQWZ5OANCyekXsSQcVieHSxUdxA5J7DMT7FgtSLorLj7Lfv32LsbMsC4PBkBIBQPzIVPVij0di0Nkbtw6UnCwuh2qKNFQUs10zEXduhyvh1P7Pfla4ebqcBYBgMIimrsQEhDhzeBebn2lCs92pylqmOLVu1R1nA8EgKELQ9LBXclAUIUgLh5V2z0MRkYaKYjYwNydZBS2hKADf/AIIlVp23nvtMfjmF9B48gCrJIb/Dr8B4VCP05TuxZoAAAAASUVORK5CYII=";
const adventurerAttack_1_03 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADi0lEQVRYhdWXX2hbVRzHPydNrZ3U2mxth7ZR65zisMuGM4HiHoz7x1ihg1rGQB/6IOLL+igMWvbu9jB8WR/0RaQMlSJbhTmVSjE6yLJAhrWWtWkddF2be3NTolu5x4dyL0narUnvORG/cEnuOeee3++b7+97fjeC/wDjMUM+bv5g5BlR6Z4VP7BVbJb8o1AuKe1Evvj63joC7c8+UfE+mxHSSmQjEqV4HKlKSsxf7sJKUQ4J2JofNoIWRQr9MHf3wSPXnT7Zoiy+NkV+jn0DwFuRniIyKpMvhDaPjMcMOXf3ATPpKwC8EDyujQRU4dRyyqxQIVW+KETV+0ghIfPW25z4IF61HJRiPGbI8Zghh78akzemVuVHH57ZUqMsRVV/jV8/HSxKOrkzQqjzEAde9nvOw+d1g0rw5egV0rN3SM/eIXUzCUAieY0bU6ueVakakTOH35CdwXYmErcBaAg0UDN2yZ33SkZbHylFZ7Dd/bSWLRoCDQDUjF0ioWD/qimSTM8VfXeUuZYV/DAyzMItb3RqPD1dBi5Ho/Ldjo4h33KePx5a7HqxjWOfXOWiAZmZaQLbg3Q8v5uz5z72ZHitikz29UuA1DaLtqYmACYSt9n5+zDfdQkC24MsL6WVxNJ2/E729cvk/RnmMxnM5/z49/XwysT3zGcyAPwZPsjyUpo9rx7wrAZoMvtkX7+8OnVz3fhPu1/XEQ7QfGq1NTW5CrTuDZEaGXbnTi6ZAPQqUAM0lJajhuOJ1DZr3ZpU3Uvs+WeaoW9/UxZfqdkdXzhw1Gisr6WxvhZYI6EDSok45i4sqVLsfa2TluZWlWGBKjTExvpazPxDAPz7egC4t7jgKqQKysx+ORp135UcNQbicdHbcUpSB9jQsrgAQEtzK+b8tJLXdwdKT62NymnOWpQ+bJHL5uTkX9PuuBBqzxmtpXVh/36ZtyxWrBW5UeKRI+/YqmIpI9J7/bqb6UA8LkaaA/LzJ2uLykcI4V4AQqqrLqWlNRBf+/8dPnrIzmezKrfeFMo7e/jYYftv0ywaE0KQmIj5AEJdEWXlVAilRAa7w/boUrbIyA6B0vtQV8SOPpXnF0WxlRA5//5RG8AwDLp3wLnR2KbeC9XlgKdVhAcUELnw3hE7YxhrxhWiLBKwZnT/6qrX8C48ERnsDtsZ0yw7eZ3wlMBsbgW5xcb22Y8p32xuhaETb2ox//8W/wLx6Vh0BcBAJgAAAABJRU5ErkJggg==";
const adventurerAttack_1_04 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADT0lEQVRYhe2XX2hTdxTHP7dmFnVdTbsmWJsoiFhaiFmhphDYS9upEwvqaimCe+i2lz35PERxjL2texHEgj4plNGBsFUmykCoBjq0RCqGrtCm8U9N2uQ2KSkzuz8f0nttEmHFe2Kn9PuS3N+F3zkfzvec3+/Cuta1rreq26GUWou4DqmN1grAVIX0hp+2bdWk93xruh1KqfeuImuldRBTb2KpgaHranQiJ2pFsakFcOXX58pTv7Gk4eN3elXoQQRX7nB+4VmIMWB0IqdadztEhoPtTcyKzDz5BwBP/Ubrnbk2Ff0dgPjweYL+JgBSgV4A/L5OJGDEQcykTe30HgJg9MLn+LwewtGZAhi/rxPANoxta5kAkIfY6T3EiaOukqQufXVEAfi8HtLzaapqqthw/SJjdhNYlm2Q1yX9OoWjM/i8Hus/UZjd6oXBAZobW+2mIdvsKxXp6bOmUjgxRSyRJEzeVt/8OMr33x6jptbLtjo3idCQ7XhlAYn09KlwYsp6jtUu0YCTaXRGxh7S/miAmlov83NRttW5+fnGX7Z7VfxAjPT0qeGJ+8SSSQDrNxLsIPhvNTsSBqevPmR+LkpzYyvdkb9F4pbNWg1OZ8laJNjB0/hswdrwxH2ReGUBMSFiyST6dgdkX1D96DcA5nGTMyo5ntRh5Cbd9+6JHIii1jJ7w7TTSunZFwDsycYAGN+cpvvWLbErv2hFTIgGp7MApnrTB0AeZrxyl2RIS2W9/X743Q8la3ubfLjq3OKxxEB+aW+3zo3iapi2cnxyBIDn8VmrSlIStVZxb3x97KDW/UWvohIwwLU8sVx1bvTY5P/3Gl+s/pYWNZiOqwoMLbOQUZHHk9Y7TZP9tBfdrb+lRQGcWh6pbfs7jGw6bb1X6lURNE1jU1UVoT9uithbtCKnVpwJxRBQWgVNybmrLFMrcKCzBKLcEu+RwMHPjCVdL1jTNI2xkVAFgD/YZkjHBGGQM10B49rcQoGFTIDiZ3+wzWjfkuWuUGwRkJ++PGAApFIpuj6Gc9dC/2lZf2UG+EgiPCAA0n9yv5FMpfKNq2mrgoB8oztyObvhLdkCOdMVMJK6vurkyylbCUxnFlFveLBd/nO8YjqzyNnD+8rS/O+sXgI/7lCeNYph9gAAAABJRU5ErkJggg==";
const advendurerDie_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADJUlEQVRYhe2WTUhUURiGn3ubQsvUsfzDHySihYJMETk11aJJK/yJAnERtRFyEVGL2iSlBm5aVBBirZKgNoJRpFEtAs1phiLHgQIRYRwt8wdnTGcwGue0qBnu4EiZ5y6C+27m3juH7z3Pfc/57gFDhgwZMmTIkCFDeknRs7irrUlo78vOtejmpyvIxYrdwmYpBmB+dp6SnaWAPkC6gVys2C1KCwvw+MbQwmzO2AxA7Y0HUr1VmcW0Ki0siP3Oz87HnmuvZUo6SKfdLjrtduHxjcWeeXxj9Ls/xa5XUq8zIFb88w+SGu9QXb3wzHgZ9/vJN5vpXzeHzVJMaXFS3Lj2Rx+4/fJ9nPfDrinh9XVzwHqCg9b0Vc9LGogWIlhVy6ZnnYxu/RX4tatn48ZmHDgb59vrDIg+5+N/hgBY968T12qorl70DA/wbXERgPfhJTJsh8h0fyQ9JMgbWSK05Ssh/xcKjjdLhwAwrZEhTvlmM+N+PwAT05Pk/k6mZ3gAhpePlwUBEhKJphGFmMszkbXkx/t9AzmZ2fzYUcK26QlSk5Opdzhik41CFBVWUl2+Zc1LfM2JeGa8ALEktJqYniQ3M5uiuy8AeAei4+Yl9pVfIQpx6mSWlH0qrf3mm80ApH0Ok/Y5TMn3EaamJzly+nJsjNvziqOWXry+booKK6nIuSDLXk7X6rTbRaJEUhpb4+6f32ng2Pl75Mw0AlDd8EFa15RWKBFMsKqWwU8e9qk++qbGyM5LRk09Rlv7belHI6ldC5Z3rqzMbDoGR4Bc0fXQpcKQbEtAhyOKNpXtrl763A4hBALAeuRwRLZfVFIjvrVrlwDoSFqf8My0MSWFxVCIgTdvpb9AqQU7ktaLlSC02rl/r/RkdDvGK4rCoMOlDjpcqqIoKEp8+I0nbVJhpC0ti80am5iiKAmXj8VmjUSBajIihE0mWrv6pbxMaV3rzPZ0AAKBANefJN4D7n6nCtBUUxYZXQiSn5Yqy17e0lKE+A3h/GPNlqcuVRECUzgsy14OSFNNWcQ/N/dXEHpJivHoQhChrG673X/9UR1dCNJcvUe3b8t/qZ/LMEKle8ALmgAAAABJRU5ErkJggg==";
const advendurerDie_1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADUElEQVRYhe2WXUhUaRjHf+9k2DRbenTLlcZBtI9lAp1KUpoKFsECyyiILpaC6KKLvSiCrrrQDWJhL9ZgafcqirYPttikJYq0D9BmOkKs04EJwowcx8wsz0zjjIY6717YDNMG0q7v6WI5fzicT57/+3uf53nfA7Zs2bJly5YtW7askvgcJt2nmmXufe133yv3/SwghxtqpN/nBSAxmmD1mipALZDlIIcbamSVpwwjMkAuzKKiRQDs/vGckjE4VASZTVWesuw5MZrIPs+9VqE8pdHe60p9vQSImiZGZCALY0QGIDIDZUQG8Bd5lXkqL60new5I4/VzwgsTFAxO4dY0AvPi+H1eqrwLPvj214t/cbL9oejUYxJgc13hfx6P0tLKQERNkwLnfNyaRtQ0AQiEHrOksuaD42T7Q3Hh6ivZpbfN2XvenCO815M9B+SN3h7eTkyQ3LabyS9X8sZTQcXIEI7RcQpTkmV906SKX5IyX1C2o0V06jFphP9kU93OOWUDLOgRt6Zx+bFBtXdmiY0WT+BmJjM3enugd+a7Tj0mu/Q2JRCgqLQy2cgtpaGR4ez7aPEEwYpVuDUNt6ax7pe7qIQARSCrfj8t3JqWvV/9ro9XI8MMjQyT/Hob8fFJAMILE5Sc+IMuvY1yT6MyCFDc7Jls5GrL3qM0/hRk6ZISVuy/noX4dtdSpSumJftIweAUG5ZH2HjkNwBCRgdbfZ0YkWrKPY00fHVIuaeSVetKfb38ZzbiTkiVeng5/IybPx+k9JtWKid/ID91njU7O5TvX5ZkBCCcX0n40jmmXwcoWeYkdPsWXaE8KYQ1v3eWgfQO9iGFkFDK02cSCALgdLks8VM2Pa1r10qAswvmp2eL63S5EELwoP2O0oVGeZ6rN9ROzxZXCIEQgnynE73jrjIYK37jsxBCCB4Fux2Pgt2ODIDT5UJKybvxcY7t8qeVm6qQz1+XHZgQgp77Dz6aKJ+/Lp1p+KaiNFN5eZy4GpjzhCpt9n3LCwGIxWIcv/YxBEAooDsAmptq0/1jSdwFi5V4KwNp3bclbcZiHL+mf9LsRhJjlH/hoqUtqKS8lQRpbqpNm/H4J0NYISXG/WNJ5L/c6M7cCzv6x5K0bF+vrOH/F/ob/wA0FshXzqkAAAAASUVORK5CYII=";
const advendurerDie_2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADS0lEQVRYhe2WbWhTVxiAnxMj2jatRpmdaw3F6ZQWYta5Jhit4sUOqStaGAUFEYQxEFkn/hljtisrgghlDPGHP2QKfhUtih9gXYe0iemffgQqiJ9Ni6iVJlnamNqZsx8ut4kdorsnMuQ+f3Jy8t7zvs859703YGJiYmJiYmJiki3Eu0jSfahBpn937/pJed53IlJftVJ6XaUAxEZjlH3qBNQKZV2kvmqldDoWEQwNkS6TPy8fgK8OHFNSg0XFIq/D6Vikf8ZGY/p8+lgFWRNp1TTZqmkyGBrS54KhIXx9N/WxSrJya92q2ymDTx8wkBujLJ6Pb0YUr6sUZ+nsjLjDJ3qobboGQKVnrqFalIukJIbDYViSQ/TZJJGJJAD7fvw6I/bKyGYehC6xxrPFsMgMIxe/yq26nfLy7V7+TCS4465kNLeIjyYfIaTks+cFdLZ1UfQJxMMPuV9YT3DgghIJyFKPFNvtACz8oJDx5ZuYkzOT4fkJ/IuXETx+l8fLD9AZaFMmAQpFUqdRbLdzxr5g2u/RZ5MAFDaf1SVO/9bIz/v2y2nB/wFlPdKqaRJgOBzmjrtSn38y8piyibsMzPqY3XsP0xloo8RRzcVT37Cn+Ywe9/lSq6FarEYuhikBeCmRYseegwB0/bCWKLB56y+6xLbaBQJgfV27dDk30BdsN1qGcRHIFIApCYDVzdd51FFBMHSJEkc1VR9+mxGrQgIMirRqmnxVAqaKu3ryGC+e+vj+yD3oqICRXzl01KqfYMfpI0bSZ2C4R1rKyzOa9bueHn3N2nUOWViUg6VgI519fj1OCEG/v1vpE1NZs7eUl8t0CZfXI6WUevFpQ3JtNgLtHf9PkXRWrHK/eN3aOXl5CCG4cfV3ZTJZ//f7byTicRLxOJ4N65Oq1lQusmKVO8k/p5HqhX5/t0UIgRCCXJtNj9XyJ5TlVXprubwefYeFEPR23Zi2US6vJynEy7Q185L8ZbXSfM5neEOVvEdSbF8yF4BIJELT+ekSAH2+gAWgocadHBwbp3hOgZLcykRatn+RDEciNJ0PvNHuhmJjlNjyaGzzK7m9lSzSUONOhqPRN5bIBkoSD46NI8XbtdvRPwYsg2PjNH5ZoezJ9V7wN61QMbvXa79UAAAAAElFTkSuQmCC";
const advendurerDie_3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAADC0lEQVRYhe2WXUgUURTHf3e3kvWzDdSKlCBSUBQVUWOtIMu+KMjS6KEQoiB6MelNUpMiCKleIqiHoofAIiLo06+MdDcVdFswsCB0k8o013XVVbS9PdhOG2LJ7qxFze9l7pw7M+f855xz7wUNDQ0NDQ0NDQ2N/wWx0A5bL1dI3/vs46dViWHBhZTkZ0pTWhIAriEXyempQOCCFlRISX6mTI2Pw2Z/j6+YiGURABSev+l3PDp1QpwfqfFxytU15FLsvmN/WVAhNvv7n8Yt1tez7P6yKOAv/ILu/YelbbAHAN3EBHtrW0RJPtKUlsSx3AzlORPRXLnVEZCvoPSIr4CmhBRWRMcCkNhST4veCUD5qaM/vbNs/dE/2+x38vLkXHO3jTHERMcqQsIe3GHH2nQAbIM9pB5cA0Bi8dWA4wi4tPocjjnnYhJSAPg40M/ngX6KjEYeve0EmBH0+Gug7hVU7ZFVRqMy9gosLq0GoLlsI12hUyRjpM/hUASphWpCvCIKGxqUMmmvaVPKLvfsc25cOEnfl3bMxkSKHJ8B6DZtho7AGh1UWH5PdHQImMmArwgAq60Oq61OGReXVuN0TwHQFeqiKSGFjwP9nCk/N2efzZeg7uyVu7Jkf6STjIJLLB8sYyT6CT32h3M+vz5nDxtylvoVU1D3kSjDYhiJwlr/lG1pM7bV8TuV+biVS1TzFdSMFO47IAFivi+/AC+sZimE4JW5VQdw7e5jpayO7N3udzxBzYh9+JOcGB/nzYd3ik0IgSEsjHX5eR5LbYOuseaaKr6ClpE0U44nxGBgYnwcACl/9HNoeDiTbjchBgMv6xpVOe8F5dCYs2XT1xCDgUm3GyEEQgj0er20Wdp0NkubzisuL2JSNZ9BESKlFN5gvwuRnc0WvXdeiJlCWDQ9TVmByaOGT9V75OKhrR4pBBDC8PAwVfcts35WZ7NFV7E729M7OsaqqEhV/KoqpGJ3tsfhdFJ1/+VvM213jbI6PIzKe+a/r0d6R8eQYn7rx/VnXbre0TEqd2WpUlr/DN8AGpwLksZyE/gAAAAASUVORK5CYII=";
const advendurerDie_4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAACfElEQVRYhe2WQUgUURjHf6OWKa46lkXqLqEEpbCYGGqmh7bsUBBFYqcugpcudgzKLIKgDkYQnbp4CMJjJJF4CVzKQmXCaFHBVnFd1xzWWVdD83VYdtgNE9uZ2Qrmd5k3b96b9//P9+Z7H9jY2NjY2NjY2NjY2NjYAEjpXvD9k9si8b7u2h1TNKTdSGdLrWisrgRAW9KoOuYGjBtKq5HOllrhdjlR/DMkmnEUOQBofdCbsp4McyTuDLfLqV+1JU3vT2ynSlqM9Hk8os/jEYp/Ru9T/DMMjX3W20axfGv52tqFsjjNrKpSJssMZYZprK7EXbknadzT5yM8evMxZT2WGvnVxKyq8nVfbBN03epIGlvU1GFIS6aRydvha2sX/ROjLK+tsXK+lW+ucspDATKWVimMCkqnfhDdO09UncN5odvwB80yQ/R2lMkyPiAQCrKRq1FFLDL9E6MwYd46lkQkHo0yWcbXeBqASHSFkvV5lnM38BZW0MAm+Tk5tHu9pmxvS7KWsjit/xNxFkJBwqvrhFfXARjP1XSTZmCqkXiaBZJMBEJBAMazKyjI2UXV9ynR/XJYCoSC3Ou6L7Z+259hatbq83hEogGAybpmFkJBvsxOJgm+vD9DWihtAOBg8QFu3r3xb5QoW5k4+WIYgDFlgMcPu3QjDkesJIlEItKzXq8+/vjhrL9forQODu5YhKbFSpK8vDwxpgwAMbNGMDX9Xh8ZkQB6amrEr9H49O5D0kc7cebUZrxt1ARYdLL3XD27GVZVgvlhaW0uS1y6ki0tF79m2v/qt3Oa6i/SXF+Ysh7LDsQCWaYAWUweOSrBWwAOuc7pz50lu61a+v/mJ3XR9CDarh1fAAAAAElFTkSuQmCC";
const advendurerDie_5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAACUElEQVRYhe2WQWsTQRhA36apNeI2rtiLtEEQrSYY2lKxWBWhUBH1UKXWkxQCXrxUf0BFUAQ9WEQRPHpQtB61SEtBhAhVaeNiCyEKJQmWNMEhLpJIxPGwGBJoFbvZUmXeaXZ2dud7+30zs6BQKBQKhUKhUCgUCsV/hbbaE07duSQrr/edv1yTGFZdZKi3U3a3BQGwPluE2sOAc6FVFRnq7ZThQAtmMkWljL5ZB6D/+v0Vx+OtTYi/Z7SnRwJYgUYAwoGWKoHK9krxOIzxj8QHIhLAUyxiJlPlfjOZIhqbK7ed4mppxQci0szNkxYCgGbDIFqXp7stSDi4vmrs3QfTjIy/XbullRaCr8f77fbTUdjiIRqbo+fEuapxI+P3HH1U10WaDYM4sJDNcNgwIGdnJ3t7Co7WAdA66EwCXBSJD0TkWGKmnA2A2Q0WIQzSQjCWmIFE7eZzTcTMzZcl3s2Z7PckwVdP2lfkldHKabEIQP/kZE3WqSu71q/tFuySCn37SL5QkvlCiXyhBNjZebFzD1eGr8llX/QXuCKSFoK0ECxkMyxmM/h99QDabMN2/L56Rp881LztfYAtWgsZV7bfmx0dEuDAo9cAxMwJbt0Yrgr2VJNG3NesXbz6uNy3d4d3xfG4fiAuha7rjBc38j6ZkjFzArBlneDKYr8wPa29SXyXsHQ2LMtC13V03f4tcSoBbpXW2SM/8kKQacxrxU9eefJMg/al6TnzyWfLPnOwq49DXZvW3snuNwz8GPLDrt0avARgW+BY+X7L1nVuTf1v8xMg4NQIsXKtgAAAAABJRU5ErkJggg==";
const advendurerDie_6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAlCAYAAAAA7LqSAAACfElEQVRYhe2WQUgUURjHf6OWKa46lkXqLqEEpbCYGGqmh7bsUBBFYqcugpcudgzKLIKgDkYQnbp4CMJjJJF4CVzKQmXCaFHBVnFd1xzWWVdD83VYdtgNE9uZ2Qrmd5k3b96b9//P9+Z7H9jY2NjY2NjY2NjY2NjYAEjpXvD9k9si8b7u2h1TNKTdSGdLrWisrgRAW9KoOuYGjBtKq5HOllrhdjlR/DMkmnEUOQBofdCbsp4McyTuDLfLqV+1JU3vT2ynSlqM9Hk8os/jEYp/Ru9T/DMMjX3W20axfGv52tqFsjjNrKpSJssMZYZprK7EXbknadzT5yM8evMxZT2WGvnVxKyq8nVfbBN03epIGlvU1GFIS6aRydvha2sX/ROjLK+tsXK+lW+ucspDATKWVimMCkqnfhDdO09UncN5odvwB80yQ/R2lMkyPiAQCrKRq1FFLDL9E6MwYd46lkQkHo0yWcbXeBqASHSFkvV5lnM38BZW0MAm+Tk5tHu9pmxvS7KWsjit/xNxFkJBwqvrhFfXARjP1XSTZmCqkXiaBZJMBEJBAMazKyjI2UXV9ynR/XJYCoSC3Ou6L7Z+259hatbq83hEogGAybpmFkJBvsxOJgm+vD9DWihtAOBg8QFu3r3xb5QoW5k4+WIYgDFlgMcPu3QjDkesJIlEItKzXq8+/vjhrL9forQODu5YhKbFSpK8vDwxpgwAMbNGMDX9Xh8ZkQB6amrEr9H49O5D0kc7cebUZrxt1ARYdLL3XD27GVZVgvlhaW0uS1y6ki0tF79m2v/qt3Oa6i/SXF+Ysh7LDsQCWaYAWUweOSrBWwAOuc7pz50lu61a+v/mJ3XR9CDarh1fAAAAAElFTkSuQmCC";
const guardIdle = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUYAAACHCAYAAADazYPXAAAAAXNSR0IArs4c6QAADlBJREFUeJzt3U9oXNe9B/DflFB4Nl48vY0RAXdhMIVA82roIjj1GJPUrwEttGoM3XlheEkw2rSFNMZJN9mIlLSQgrvN66YqCFLKC8VSXd4iENqAoUhkEb+EwYVXFePGi0fLdKGc8Z2re+7MyLb+3PP5gLA0Hokrz9fnnN9vzr03AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgm3r7fQAH0RNPfHlYf+zvf/9//1YAAMC+UaeQIxvkyAY5srHtif0+gIOmGoz3Xvnu6PFvLf98X46Hg8XAAQA8btYbNFGnkCMb5MgGObLxwJf2+wAOqvde+W58+xfvR0SM/qRs9YEjfQAAPCrWG0yiTiFHNsiRDXJkw6n0O6TF6O+Wr409/swrP/BvVbiUjTRw/Po7z8W3f/F+/GPwv7KB3T1kyQY5skET6w1y1CnkyAY5skGObDzgVPoG3pWnzbGvnIyb3z8ZERE3v38ynnnlB/t8ROw3pyGQIxvkyAaTWG/QRJ1CjmyQIxvkyMY2p9LDDAwctHEaAjmyQY5s0MR6AwBgb9gxWvPFKWzDe598HMe+cnK/Dwc4ROzuIUc2yJENYFrqFJLl5bdHZx38+Ge/jK+dmouIiHo2FhYWh6urK8WdFlsy2SBHNvKKb4w2heOnH/81/vPkv8a9Tz6OiIhf3f+XIsPBOItR2tjdQ45skCMbNLHeIFGn0KSai6p6Nn768V/39LjYf7JBjmy0K7oxmgtHxPYiIxkMBntyPBwsFqMAwONmvUETdQpN2nIRsbOpMT8//1iPh4NDNsiZNRslKvYao5PCMRgMRh8RBo7STFqMpg+LUSIe3EU6FbCQyAY5skGE9QbN1CnkrK3dmPq58/PzMRgM4vLll1rzRDfIBjmzZCOizDml2B2ja2s3ot8/N9VzqwPHO+/8xDv1HTfNYrSqxIGjdHb3kCMb5MgGddYb5KhTaLKwsDiMGG9yfLSxNfZnumZg+jrlg26TDXJmzcZ/nHuqyDmlyMaogYM2FqO0cWobObJBjmzQxHqDJuoUpvXRxlbMHX9q7LFP727/OXd8PiK2dxX//re/ibmjR4Zbn983dhRCNsiZlI3BYFDknFJkY7TOwEHyMItR2ei+WXf3RIQithCyQY5s0ETzi2mpU4iImDt6ZGwuacpF3erqSq/+fXSPbJCzm2xERJFzSnGNUQMHOU2v8SyLUbpvlt09EZrmJdltNug+2WAaml9EqFNo9/vf/ibOnL8Qq6srvROn+sOtO7eyz729sdaLiNj6/H5v7uiR4atvvBlLSy/v2bGyt2SDnFmz8Ydo7ot0XXGLqvQiV8PR9vw0cKTv/WLgKO7frQRzR48Mz5y/MPp6msXoH9a3d/TIRrfVs5GkXTxJdXdP+jw1zRWx3ZV2flXJBhGyQbPdrjeqhYpsdJM6hSZfP/Hk8JP/25470v/9WbIR8eDsBfnoFtkg52GzUdqcUtRd6b9+4slREHZzY4MUqEmnxXH4pGykYjTlY+vOrexHaopGyEaJUiFb/fj07nx8enc+5o4/FaurK72Uo1ffeHO/D5c9NE027DIvk2yQ7Ga9kdYa5pRuUqeQk5obj4J8dItskPOw2ShtTimqMZoLR71IqX7klBKQUlSz8bB3A5aNbqkWKsm012eJKG9SKc1ur92jwdF9skETzS9y1ClEbM8d1fljefntYZoP6jvFZ8lGKbu+ukw2yHlc2aj+vMd17AdFZxuj04Rj0lbiiIh/P/vS2HMMHIefSYVZpEJlt7uJq0qYVEpkpzk5skGd5hcR6hQmq+Zjc3NjrEbZTTaqP8vYcbjJBjmPOhslzSmdbYwmbeFI2gqV3MVpDRyHn0mFukmFSnV3j6Y5uZ1fGhzIBhGaX0ymTqGumoHqa7iwsDisX7d61mxsbm7EO+80v3nPwScb5DzObESUMad09q706S5rETvDERHx6d35qX/W3PGnhtWdHGng6Ho4umpSNqpFbNtd25rIRjdU7/i726Z5067RNKkoaruhvvNrN9lYWnrZeNFBskFV25ySzLreSD/LnHI4qVNoUxkjhhERg8EgIrZrlNzGjCb1bKTGlzHj8JINch5XNkqZUzrbGI1oD8eJU/1hbodGWpymv68vVg0ch59JhSaa5uSkXNRPcf7RD7+3o8mhwVEW2SBH84s26hTapP/ba2s3Ro99+OEfhxERl5auN37PpGzQDbJBzuPIRilzSqcboxHt4Vi8eGXs9LUUgnuffTB6LP39iVP94e2NtU6HoTQmFZpomtMmt/PLO7HIBk00v2ijTqHN5ubG2Nfr6zcjIuL68qWxWkU2yiMb5MjG7nT+GqMRzeFYX78ZK+++teO5f7v759Hn9z77ILbu3Jr67tMcPrlsXF++NPZ4uubGvc8+GOUimeYUSQ6XXKFSz0VV/bosmubdMunaPW2v96RsaHAcbrLBJLk5ZeXdt3a85tYb5VGnkJPeSImI6PfPjT5vqlVkoyyyQY5s7E4RjdFZwtHGgrR7DBzkaJpTt/X5/V61CVbd+RWxs6klG+WQDSbR/CJHnUKT6hspV6++FmfPPjv297PkQza6RTbIkY3d6/yp9PVwRDzYTpw+v758KRYvXhk91jt2Iob3bu/dQbIvps1G7rT6qhK3m3fdpEKlmot6ERuxfSqCXaPdM+m0xzrZKIds0GaWOaWN9Ua3qFPIqV7XfnV1JSIezCkpI9Umx/MvvCgbhZANcmRj94pcWNXDERGjbvrzL7wYETEWjmNPfmP0ucVot82SjWNPfmOsiJWN7kg3xohoLlQitnNxael6bN25FX+7++cdY4ZsdNPy8tvDzc2NxiZHykQiG2WRDXKmnVNS8ys1za03yqROIWfu6JHh+7/7n9HXKSPVfMhGmWSDHNmYTjG/aNU04YgYX5BWlRSQ0hg4yNE0J2K7+VXd4VPd+RUx3jCP0OAoiWwwC80vctQp5MwdPTKM2H7N02U46mNItVaRjXLIBjmyMZ0ifsm6FI6IiLTwaAtHhAVpKQwc5GiaEzHbzq/qqdKy0X2ywSw0v8hRp5BTzUZ6My2dElsfQ5775jOj5yWy0V2yQY5sTKeIX7KuHo6I2NEEq4ej+txSwlEiAwc5mubkTLPzK0KDo0SyQY7mFznqFHKashGx/Zqn+aaqXqvIRnfJBjmyMZ0ifsm6dIOEH/3we1OH48z5C/HRxtboeXt1rOwtAwc5mubkzLrzK0I2SiEb5Gh+kaNOIactG/92/KvDiIj/fu+/dnxfun6xbHSXbJAjG9P50n4fwF5rumts1fMvvDi2iyNi+538q1dfKyYUJXv1jTfj1Tfe3LFrJyKfjWrRSzm27tyKxYtX4vTpp3tnzz47KmAjHuz+SXeapvue++Yzo+ZFysL6+s1YX7/ZuNiQjXLIBk3SeiPiQdExaU45c/7C6LknTvV3NMg4/NQp5EzKRnL69NO906efHstCetOFbpINcmRjesU1RquqC8y6pnA0vUtLd+QGjuq7KX+586debuCwIO02TXNyUja2Pr/fW7x4JRYvXolqYyM1wKp5OHP+wn4dLntINmjStN6oriHaml/159Jd6hRy2rKRnD79dO/atddHX6+8+5aMFEA2yJGNdkU3RldXV3oR4wvMv9z501hYSg5Hyb52ai5ub6z1ZsnGhx/+cSgb3aRpTk4uG207v86cvxD9/jm56DjZYBrVRvjtjbXeiVP9YVpvPP/Ci5FrfslI96lTyJkmG0k6QyGRj26TDXJko11xjdG1tRuNW4knBeTatdeLC0dpqtlIA0eSGzQiZKM0mubkLCwsDuvNiqadX1evvhZnzz47apzRfbJBVdt6I6nOK+aUcqhTyNltNtL3VN+8l49ukQ1yZGN6xTVG+/1z0e+fyy5Em1Sfu75+M0oJR2lkgxxNc3KastG02GjaTVzdLUj3yAY5beuNXLGyurrSM6d0n7UoOQ+bjfSGW9Ocw+EmG+TIxvSe2O8D2GuTLjw77fd2PRglkg1y+v1zERGxtPTyTJPKwsLiMGK7UFlaermXdvnISHfkspFrbtQL1i8ubC4THSQb5DzsemNt7Uasrq6YUzrIWpScR5UNukc2yJGN6RXVGL18+aVhRMRgMNjvQ+GAkQ1yLl9+abi5ubHrbChUuuthspFOi003U9Hc6BbZIOdRrjfkolusRcmRDXJkgxzZmE1Rp9IPBoNHEoy0C4zukA1yZIOcR5GNa9deHzXCnPbYHbJBjjmFHNkgRzbIkQ1yZAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAIv0T6d0+WvwuOEgAAAAASUVORK5CYII=";
const guardAttack = "data:image/png;base64,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";
const guardRun = "data:image/png;base64,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";
const guardDeath = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABL8AAACHCAYAAAD3GvtEAAAAAXNSR0IArs4c6QAADyJJREFUeJzt3V9oXFd+B/CfWmGI3RCqJ2OSOA/Beqghcbz0ISSVjGmbTYtK/WDogl5cb1CpEha9OAt2zGJD65dht/aCd3HzsrBdCuuAaZa022BpHUpJI9YBv8h4QSJBuBC0BNculMDtw+SMz1zdmZES29Lc+/nAIGk0Hq49P98/3/s750QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQG5kqzdgOxod3VGUn/vii//zbwUAAAAwZEa3egO2mzz4eveN6c7zf9r6xy3ZHgAAAAB4YEZHdxSjozuKf5376+J39zzd+brV2wUAAADA5hnKV5I6v37V+l7X8y++8V3/VgAAAABD5ne2egO2o3y4IwAAAADDy5xfsAEWQQAAAIDh1Ojwq9U63wk0fvCjn8dz42Od391ZvhWPP/PslmwX24tFEAAAAGB4NXbYYx58lb1z77GIaAdgd5Zvme+LiGgHX6/+7JcREZ2vAAAAwPbWyM6vfsFXRMTq6mq8s2fPo9ochsTjzzwb195sdwNee/PZePGN727xFgEAAACDNLLza37+6sDXrK6udh5gEQQAAAAYTo3r/JqaOlJEdAdgHy+tdX2NiK75v6amjhRXrlw29LEh8s7AubnXfe70ZCEE+inXh9oAAICt0bjwq+zKlcsje8cni7Hd+7ue/+Tz+98/9cSqAKwhykNiU1gaYREEulkIgX6qgtHR0R2FAAwAAB69Rg17HNu1s+tiJA+z1m7fGPjn8yCE+tnsIgjqgQgLIQAAAGx3jboDncKvlw6/0hV87R2f7BlipOGPe76cAP/ixQuN+jdrkqmpI8Xk5KGu5/LhsXuyRRDyueB0BDZT6uz5Vet7Xc9bHZaIvp2B6gMAAB6xxgx7fGHvk8XyZ+05vTYaVqwszY+sLLVDERPf11uvueDyud961YAhsc1lIQT6SfXx6s9+Gdfe/Jst3hoeNXO+AQBsH40Jv1Lw1U953q+VpfmIaIdlU1NHig/efy/Gdu0s1u7ecwJbc4MWQUjybjDqyyII9JLXxg9+9PPOfuJvn/39iIh4/Jln49qb7bkCdQU2hznfAAC2l0aEX+ni5OypE9EvuMrn/SoHYR+8/97D2jy22At7n1w3F9ygRRB+vXBhREdgM5Tngts7PlnkQaiFEJpr0DyBf7nzf+PO8q2IMNwRaNMRCABbo5bhV5rbKw+6bt5cqgy+DkzM9rx4OTAxW/x6oT3H19rdeyPpfXV/1cvyZ2ux/P576+aCW7t9Y10ImtMRWH/9wo2I9QHHD2/99pFsF1tvUG2srq7GO1lnqOHRzVQeGm012GbTEQgAW6fWqz2O7dpZDLpAodlarfPFyTPnIqJ6Lri12zfWPVIgGqEjsO7yOeCqrK6uxjv3Hus8IqwK2xSDaiOiXR/pEaE2mqZqTsC945NFv0V2AAB4OGrZ+ZV3aeXShceg7p78ubyj5+j0sdi3bzwiIubmXn9o28+j1asrsMrK0nzX63QE1levRRDKqoa+6vKpt361MWieQLXRDCn4yodE//2//1fne3XQPDMzs8WlSz+OiPXB6Gvv/qYon18AAA9WbTu/1u7eG0kdPTdvLnUuUMsnm1XBVy8XL14YuXlzKSIGD3lh+9vIZzi2e3/Xg+bKQ42Pl9Y6j7I9e/ZYCKFh0nGlvL/45PM9nUeE2miKVut8kTpB7yzfijvLt7qCrxSK6gRspl6rBKuH5hkd3VGUH1NTR4qpqSOFLlGAB6+24VeSB18REYuL14vFxeuVB5MUfN359MOu56u6yG7eXBKANUA+3LGXo9PH4uj0sUhhK8OvahGEdFd+UMCRD3OjfsrHg3IncT9qo/7SecHq6mr88NZvO49eBB7NkncEpsdr7/5GIErHL37xL10/C8AAHpzah19pmGKysHAtFhauxeLi9SK/iEkXLf/z+X/H3m8c63oul7q/Ll68MDI397oW9SGVLlDSZ5n/7sDEbFEOOFLXV9UCCenPC0TrY/mztc58buVu0X4BR3ptWgThYW4jW6dXbUT0nicwvdZQt3qrmguuV6eoTsBmSYFoRHVHYCIAa45335he98hVDZ0H4Kur/Ul4fhIxOXmo63cTEy/H8blLXcFXRMTT44cjon0Rk3eBmc+pHlqt80UeerVa54s8yOy3AmhEdE14n79neo/y+zFcUoB59tSJdf/n+92B7XSG5aG6fUatvLD3yWL5s3aAsdHayOfxURv1lp9vpE7QKmu3b3Rd1ApE66/VOl/0mz8y1UMKQ8s35ain//iHvyvSatG5creofQTAg1Hrzq/8RPT06bdiYuLlrt8vLFyLS63jEbF+qGM5+KI+5uZeH8lPLMtBVVVnT/7cgYnZrq7BmZnZrrBL8DX8NrMIQkR3wJH/Od1f9ZKCr37ME0g/6ViSd4lSf/PzV7uGyJf3EykMMzS6efJFMZJyOKobEODBqOVqj0l+p+TKlcsR0Z7zK6IdfKWvl3/6/YiI+JM/+6t4evxwrN2+EStL8+tWjLSaXzPc+fTDrovWdLGSvuYrgUa4Q1snGx22Wg41xnbvLyKquwKph34dgbl+w2KtDltf5fOFXy9cGBk0V08KvtRCvQ0KLtI+4+OltXhufEwg2iD/+cXvxR98er3ruTcXH/vyHKMdghoaDfDg1Dr8qnLw4PMji4vXi9QFluYAm5h4Of7t3X+KI9/6TqeLI79QoRnKn/egLrD0Z1y4NMOgTp4DE7PFykdvd34+eeZczM29/rA3i0ekX0dgr9q48+mHjiEN8cH778VLh1/p3HhbWZrvBGDl+ijXhSGx9ffUE6uVKwTn8kC06vdqo17m56/GT3oMkU5haOoEHHQ9ojYABqv1sMdeDh58fuTgwedHIiLKIVjqAkvyg8lLh195lJvJFlr56O2ukGtlaX7EMNh667cIQpWNrAR69tQJiyDUgM+QfvLVYXvNzVNeBKEfN93qo/xZrizNj3TNA7jJYdJqoz5SR+BTT6xWLpQScX/440a6AdUGwGCNDL8i2hczeddXHoItLl4v0vDIiHbo9dLhV9ZNmM/2N7ZrZ1F1QjA1daTY7BwK/e6qmY9huKVFENJ8cL3Cjl4XrfnJalotNpmfvyo8qblBi2T0Yr8xfKqOKcufrXXOE9a9vmLl4I2EHGqjPjazOuxGqI36eW58LHqFopsZBqs2APpr3LDHsvn5q50JyvPAK/188ODzI1euXB5JBxQr+Q2nfkMT0+cc0R6mdvbUia7f5yck+ffllUTTvHIMn/L/6ar/42O7dhZ3Pv2wayGMx5/8w67XrN2+EWO793ddBE9OHrIIwhDbbEfgIOXamJw85JgyhPJjyskz5yJfyS8/pgxydLodlu/bN971Ho4pwy9fHXbQan0pEO3VYV7eb6iN4VYO0Mv1sdEgNEJtAGxGIzu/enVh5MMhk3IXGMNl0BwIqQMw/4xPnjkXJ8+ci4jusKusfLKiu6dZ1u7eG+kVjKqNethMR2Cv+QHX7t4byR8mLx5uX+WY0ut91u7e61p5uNxdbr8x3DazOmyydvfeyNHpY3F0+licPHOuUyeOKfVT1RFY1f1VVj6mqA2ov9HRHUX+mJmZLWZmZoupqSPF3vHJYtACO9zXyPArmZ+/Wnk3rioEO336ra67sgyPdIKQfq5qC08XK2n4682bS32Dr2TQ3VyaIdXKytL8SFrxUW0MvxR65T9XvS7v1hg0fOnixQvrLlYYLvkxpdU6X1SdG6RjyqXW8YHvt2/feKe21EZ9pJtoqbuvrNfw13yfkwcZaqMeNjJHYF4b5akUqqiN4dcr3BBwMDq6Y93nfunSjzuLYSRqZGMaF36lE4lewVeuHIKdPv1WTEy87K5KTZTvsudzwH3728c31fUnGB0+ae6e8vCDNB9c+vwH1cGgkFRt1FvXKn1fDntN30f0nw9MbQy31BmY9DqmXGod73pEdNdFCr7ycFVt1EMKwKpUheSpLvJAtExtDLeNdASWa2PvN+53A/ajNoZTr3AjIioDjgMTs8VXnWuUeimvIPzNQ/tjZma2yK9xyo8t2tRto3F3CvKun83eKckvgDc6nwfbT6qB06ff6np+YeFa5etTN1hE9ede7iRzB244VB0AynNnJHkN5AbtB9RG/eV1VJ4DrvOa3fsjdQQmaqM+HFMoGzRX4NiunUXaX4zt3t8VnEfEuv1FojaGX6t1vjh76kQcnT5WWRt550ZVd+D0X1QHo2pjeFWFXxERx4+/Fqurq+sCjojq2lj56O2unwcN02c49KqPV1/98/jk8/ZUGmu3b8Q3D62viX/+yf2aSOH52VMnOt83cc7Zxv2FZ2buJ+Wbnby4fIIrABs+6TMsnxRUdfbkFy69wo+Idh18nVCVrVMOwFL4tdGVXQfVRcTXC9x5tPrdEUu1UQ44NuLIt74zMABTG8PJMYWHud+o6ixWG8NDbdDLw6qNdJzJF+9qctAxjB5WbfzxH70YR6ePxb594xHRvjkT0e4ubNL+ojF/0eTrHBjcVam3cm18nYUOBKPDJR1oeh1UenVwJP0uZMvUxvb1sE44Nkpt1Eu5K/DyT7//ld9LbWxf9hv0ojboRW3Qi9oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2pf8Hf0tEmI1JKYoAAAAASUVORK5CYII=";
const slimeIdle_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABSElEQVRIie2UvU6EQBRGDxsTC2uzhVkkvgDV2mx8AUOhnaW9pZFYma01vseUFBsbC3pJSHwBI0YKQmlothArJsPPALuYWMjXwb0z37kzcy+MGjVq1H+XsUmyF2R539yz+V6vvXc2MRZ+CsDH60rGkjji8WFZyhd+WoJtg+mk9IIsF35aMq2aH+1PADi/vJOxAqqABhCuVfNrBehr/pZ+c32zLMWnB4cAmLbTCqC9gi7zQk3m5ZyVBPGCLK9eR683APA8+wTgKwxZYAM0GreBCJxaXAugVp/EEU/hCyezXRZruy9zL3WeQFHB7fQY1tsbJXGE2cA+0S0QrmWYtiMf01DNT68a/2sBVA2FaFuvbcOL+3c5SNS3MMS4aEm1HWsATca/LdN2JIT2Cqrm6kDRbVrNUb+LeDVHnoBaeVXCtYy2+DZqmop/oh/qoZSIlDQ3vAAAAABJRU5ErkJggg==";
const slimeIdle_1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABSklEQVRIie1VMU7DQBCcREh5AXJhxUZ8wBU0iA8gP4A/UEZBlKkTReIHtC5dRDQU6bFkKR9AOMKF5RK5SYEprDuOi3fv4ogKT2Xf7u3Mza3XQI8ePXr8dwwO3RAnVW3KidYlovszq9rWAgRxtC7l2nazIvO9IGzEGIRYCYiTqtaJizzDcjHD+ekQb+UXJtOZjC8XzbO6hxJiFBAnVT1/fPq1xpEDgOP6AH5c4AQMTeTqKQQ5AJJc5BR5hu1mJa/pdv7e2jukA4JcFHgZfwAAPtMUV7uA070Hx/XhBWGrCyc2BYo8w3P6iuvx6GByE0gB6ukB4MG5BHbdSIo8g0foZntAbD4WFzd3ZIwV4AUhHNeXXd0VXCOSTagmcwOHc0gX3jac9gTYEh8D9Ysgr0AnV4cKVVTPUd9FXM+RDlCDAmgs4+JdYPuz+nN8AzZCmqYelNueAAAAAElFTkSuQmCC";
const slimeIdle_2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABLklEQVRIiWNgGAWjYBSMgpEOGMnRtOH01//EqAsw5SZoPskO2HD66/8V+18zMDAwMDy6uIWhrCCRgYGBgaFrwnwUdTBxQo4gygHIPl6x/zXDo4tbGBgYGBhmtCYz3Hv9j6G4tAFFfW93A0PXhPkMcvo+ED1lCjjtYSHGcnTfwSwPTKjDqgebelwAbwhgs/zl04dEGy4uLU8wFJjwWQ6LawYGBobdsk8Y1r3eRLTlDAwQx8KiCxfA6QB0g7ZtPE6S5cQCnGkAlthgQV4hbsbA8Iv6DiAYAuLS8tS3lVgHwBIQJY6ApYOIrgdYCy+cuQBZA3JU4HMMeg5BVyun74ORGzAcgG4xLQCyQ3BGAbrlsOjAZyi6GmQ+TB5dDTwEcMURAwOkEMEnTw7AVzzTFQAA6sKANH+HUugAAAAASUVORK5CYII=";
const slimeIdle_3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABO0lEQVRIie2Uv0rDUBTGfwY359JBjNIHMFN9CMmgm6POOjgVJ3FuEXwDp0LGCsHFoVsVOvUFxBQzhMwdtQ7lXm7jPfnTgC75bcm5J993z3dvoKGhoaHhn9mqsng0XSxt7zsth/f029pz0t3J1diuIhqMUwDmsxCA3vUFnZbD6fntWs/94E6vH00Xy2CcEvQOrEZyDahmJWiSxJFVHKD/8AiA6/natIQ4niLxMrR397URwDqFwggUL3ufABy+fZVtMYyG2kQWR2o2d5/EEc9Pr5XEy1I4AbWLm/bRxiJJHDEZ2g+hOAFYZadyrEP3+FKsyREYB6auifks5Kz/Yf2HiBGoBtfzrTehyFz2pkjf+JWL6TRPuA6T4ZXWFSPIikvXyKxn15jPqu56/tomtRMpI1idh7z6Jki/5j/nB6FtgbOlx5M3AAAAAElFTkSuQmCC";
const slimeMove_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAAA/UlEQVRIiWNgGAWjYBSMglEw0gEjJZo3nP76H5dcgCk3UWazkGuRkigTQ2BCHZzf293AwMDAwLBi/2u4HmIcgVcBzOIV+18zPLq4hYGBgYGhrCARw3IYEJeWZ2BgYGCQ0/eBi60oU8BrB1bJDae//ke2FAZePn2IzyysDiHkACZqW06qWgwHoIPdsk9IMhDZEY8ubmGI6HqAM6FidQCy718+fciwbeNxki0nBRAMgQpxM7INJyYUiMqG+AAswRECVtFT/h9bmoORIDEEYK5FjgZyLcUFkB2C0wHIAD1HYAOwvI+sVk7fB85HLhsYGBDlA848Sij1UgoIlQ90AwASHnYjhCSWagAAAABJRU5ErkJggg==";
const slimeMove_1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABDklEQVRIiWNgGAWjYBSMglEw0gEjpQZsOP31Py65AFNuguYT7QBcFimJMjEEJtTB+b3dDQwMDAwMK/a/htBlCnjtIOgAmMUwAx9d3MLAwMDAUFaQiGE5AwMDg7i0PAMDAwODnL4PXAyfI1gIWd41YT6G+MunD7FaDpODgC0YDsEGcLoMn+XEAuTQwBUKeEMABnbLPmFgYGBg0Dvxl2jLGRggjoU5AhdgwiaI7PuXTx8ybNt4nGTLiQVYHQBLcLDgrhA3o4nlOB3AwACJN0LBRwjA9MNyDkkOQDeEFEthGAbw5QSsKTOi68F/fK4mFsjp+8B9jysnYAhEdD3AWbRSA6woU2CM6Hrwn1AJSTcAANFQYj6jFjSdAAAAAElFTkSuQmCC";
const slimeMove_2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABFElEQVRIiWNgGAWjYBSMglEw0gEjsQo3nP76H5u4kigTw73X/7DqCTDlJmg+XgXIlq7Y/5qBgYGB4dHFLQwMDAwMZQWJDEqiTAyBCXUoenq7G1DUryhTwGsHTskNp7/+X7H/NdxCZPDy6UOG9QuaMCxnYGBgEJeWZ2BgYGCQ0/eBi+FzBFYJQpYTA5Adgs8BLMQYtlv2CQMDAwOD3om/RFnOwIDs0C0MEV0P/uNyBBM2QWTfv3z6kGHbxuMkWU4KwOoAGID5okLcjGwLCEUZXgfA4pGWAKcDkFMxJcDUKxuvPMFEiCsUiM0Njy5uwesZnA5Az4Jy+j4oYugOg1mCrAZdDzaAkTUiuh5gLXKpBQiVjHQHAG7paGTXu/zAAAAAAElFTkSuQmCC";
const slimeMove_3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABB0lEQVRIiWNgGAWjYBSMglEwCgYYMBKjaMPpr/+xiSuJMjHce/0PQzzAlJsoc/E6ANnSFftfMzAwMDA8uriFgYGBgaGsIJFBSZSJITChDkVPb3cDyY5hwWX5iv2v4RYig5dPH2K1nIGBgaFrwnwGBgYGBjl9H3x2ogAM1xGynBggLi2P4pAVZQo4QwFrCCCD3bJPGBgYGBj0TvwlynIGBmSHbiEYGkzoAsi+f/n0IcO2jcdJspxUgOEAGID5okLcjGzDiYkynA6AxSOtAUbiiOh68J+BAZLliE102ACyB/AlRqypM6LrwX/0XCCn74M1Z6Bbgk0NekJEdgjO7AELCVoBfFmTrgAAwVBkTjY5pq4AAAAASUVORK5CYII=";
const slimeDie_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABVklEQVRIie2UoW7DMBCG/05jw1VBpa7SHqBoA0UtDxiM1FcYm1oNDk5BAy0emmRYEI2GDSyob9BUCoiCiz3Q2T1f7MSrqpHlQ4nsu/+/O9tAS0tLy3+nc0rQOt1LABBJCQAIp10AwP3t1a/z1QYoIS7mEgqjrd6vTDUZsy7wCiliMaw1HUZbudvE+n8wCmpNX9rERVKCJ/ERB2DEadNJiXW6lzYThgGXeDjtInp9a9I2KPLs5+uQSyCwmrhwiRd5hiLPkH6sjMQ3k7mEg/FsKU3xY57dJraOtDICykvxBQB4nD9rgc/3h9oxUHEfdAd49Ur8qXdnJFdVcsazpXSJ9/rXzQaoiBKm4j4mTkGPQCyGncM9jr3aqM6Cqq4pRt0kjnOe9FGho3FhM8Jbb7vOFQM24XMzGAXaROUMuMRdLaTrfA/9V+t8j+4ArZxzPB/nw+dV/RO+AZ4LvequnkpfAAAAAElFTkSuQmCC";
const slimeDie_1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABaklEQVRIie1UoW6DUBQ9NHP7AAQJkOwDUExUTTeIySb9hM4tJZOTS9VEq6eWICtILW5iKP6gkCAIuvpN3bfL48FaVtOE43hwzzn3nvsARowYMeIEzNcHcbXig+t36VHs0qO4RPd9HDc6YQCIkhpFFsP2gsa7R//WGGJiutgIAPj6fGrUNx5IfP3+Ic/UgnMxXx9EkcWoyhym5cD2AkShKzknXDxKakRJLYurMseQGKgRACDxLkzUAyrgRUUWn7VMFNN0sRGcR2dEGqDMVTyvXlGV+UkmqPOu70zLaWm0lrAqc7xV3wCAF/Necf9rgudIoM6j0DXU7k3L0ZpukNCm9mWmW6S/OLh47y3gBDojpuXIM3+2lCbUkaf7bauuy0Argi5BMkRk6X6Lu4eV8GdL8GvWNz0deifQB9101HM1d/qp8fhaBvg4dbfiEuA71BmBKm57wb8M8V86hzSgLhIviELXsL1AdJFcNX4A3VnfoIgRJrUAAAAASUVORK5CYII=";
const slimeDie_2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAAA8ElEQVRIie2UIQ6DMBSGH83cDoBYAtwANbMzICZJdg8OUTUxP1uJqOcAVb1BaYIgaHSnHilNa0aTTfQzTV7a///fe0kBEolEIpFI/AstVeYXviS2YC9WbyPBBnuxmpYq04vV3B6vqFNwTX0hCBsW0JIDfb5hnsbdpaNrYV2VoQ5Oxp0QYV2VFXWzFbTk0FJlWqqMLfBNAPsdNsqGZReCYNKibiC/lDBPI2jJvZ0cQUu+abNh2eo7YTuxlhzsyfhC9GI19+s5GA710Dy/lAAAUNTNpncKpbVPO4hNyNw2RtDcrWfuIx+sq7KY/0SMlUbjA9MGi+uNep3GAAAAAElFTkSuQmCC";
const slimeDie_3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAAAWUlEQVRIiWNgGAWjYBSMglEwCkbBKBgFo2CkA0YYwyp6yn9ciuT0fRhWlCnA1UZ0PfiPzEcHEV0P/jMwMDA8urgFrzkMDAwMjDDF+MCKMgWi1JEK8HmCbgAAogEXA0AQuxUAAAAASUVORK5CYII=";
const slimeAttack_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABK0lEQVRIie2UMUvDQBiGnxbBwTlkKLXFP9BJl+LQ3cExq/9AEINjJ4eK4D9wDU4dgotDdwuB/gGxxQ4ho3RxME5fvGt7yQXBLvcsgePue997v+8CDofD4XDsmEbdA+PpKrfde358UFl/r65wNMmKtcUsJry84MhrAnD7lBIMPGSfatZkxiqB8XSVR5OMxSzW1kX8Lfvm6nq4ce7+bliYEaKwq2lWJmAST5dzAKM4wOjhEYDD3pmxfmkCJnHVgA1+q1MYCQae1g7rGQB4aX8A8Jkk9OlZn/s1GxOhp1FqQL19upzznLxy2t6n/2UvXkWz1EDYbaj9u/FP/iS+bRa2JhCM3nNA673f6tTq+zoyB1JfXsNGAqq4OJavWqSusOklFNMowv/F+v9gZ/wArbZ5ZbANGY8AAAAASUVORK5CYII=";
const slimeAttack_1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABKUlEQVRIie2TIW/CQBiGn5IlE2hS0UDJ/kBVZ8jE7FLBHHLoGZJlzdQyjeIfzFYimpkJ/Eia8AeWlayiqVwwE+vUlYOU5goJmHtcv/Tuee++70Cj0Wg0mhNj7LtwOl/lqv/23eZOz9m+4mCWAbBchPijIRetBgC3d88AmJZdGnY7TK0bmM5XeTDLWC7Coibkn9kfD48vpetMy8YfDYvQAIHfNQAah8gFVXLBePJaWle6gSp5msQqWwDrtnQcj8F1i77bNGrPAMB7+xuAnyiih6O8bh02JMADFIdQPn2axLxFH1y1z+n9qst3oTQDgd81Oo5XfD+ZlwfJ5b0qb2Aw/sqBjd6bll2r79vIzxNKhlCWyknlFtQVpkmMe3O/URfPsAggxMdCBDg5/+9VduxdA4b9AAAAAElFTkSuQmCC";
const slimeAttack_2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABpElEQVRIie2VIU/DQBzFXxcceqloWBf4AFXDYMCSCnCVeHBkC4pMb0H2I5CcHElTgygKRJMl/QCQrWFiqSQzCIoYd/S2u951jBl4pk3veu93r//7F/jXX5dRNjiIZ7nuQiet7dK1ZNoqMyZRBgBIk4CNTSdj3PS73HwSZRxsFZglgEE8y0mUcaaL5rv1GgDg9OyajXlHXQ5GF4KbpGv+kn3gst3lxk3LBgA0HPcLqK6VBEtAZU4lMufnzN8ncLWSENYAANzvvAIA3oZDHMABAKGxCMS0bKRJAAJXOb9Gb4q7n07GCO+e5ubvjnIREYSuvgE6TYN+PwC4MvdXMq+q2uKDhuPCtGyYlo3nh75B71dRmgTweqPSXrIEQJN4vL0wALBr6/gcxatK9DOoIDgA0mkKK5ZCmJaNOPS1IajKIJYSkL0Qhz4743HoVwIokxCA7vinKp4GWQpCgE3q1wFUPUEKQDpNg0a2d9hm0a16JCsDUBXNi4WoqyKwqA6k/wKvN8pl1b7OFITV7vVGeZoE3G5Ff8kqWkyO9hwGoGqZ65as6W1cn6by1MuYuq5cAAAAAElFTkSuQmCC";
const slimeAttack_3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABgUlEQVRIie2TP0vDQBjGnxQ3Z3EQY/ALZOqi30Ay6BZw0bkOgphROkcEBzs7CTdWCF0csukQKOQLlDSYIWSULg6NQ32vd/nT2qSKQ37LXd673PPc+94LNDQ0NPxH+t4kzc7F2DpplQmbdpDSt2kHvyIOABvZwMHpQ8rcBABg3z9C1Q2EvgMGY2EWjtubyloMAEDoOwDAxSlm+7N16/Jc2s/cRDK3ihluoO9N+M2zRog4GuPutov9rVnlTs5uhNUOn5GZnxhpLdtQJD5KphnxmVkyzNwkl5UypBJkbyyKE6Nkiqvr7oI98/KJJsqywYNUAjLxsvsOAPgYDnH4qS+7SI7tnT0+V3UDzNIKDfASiOJxNMbg+a2yOJ1BhL5T2sqSK9MO0tB3pJ/rIGYBKM5Erg1V3YBYRzErdcTLyHUBszRF1Q28Pl0oonD7qCONVcSLSiFlgFmaYtpBSqM36IFMxFFvqUAVci+THIa+812Oufs6iGcB4G8h9whrqaxAWVv+OV/madK5QI8wiAAAAABJRU5ErkJggg==";
const slimeAttack_4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAZCAYAAABQDyyRAAABKklEQVRIiWNgGAWjYBSMglEw0gEjPskNp7/+J9fgAFNuvGbDAAs+i1fsf83AwMDA8OjiFgYGBgaGl08fMvR2NzAoiTIx3Hv9j6G4tAFFn7i0PIYZhByCIbnh9Nf/K/a/hlsKA4Qsx+WQsoJEBnwOQQkBfJYzMDAQZTlMPcwRXRPmw83G5gi4ACHLyQHIIcHAAAkNdEdgTQMMDAwMu2WfMDAwMDB8fn2RwfqXPtmOIASYYAxk3798+pBh28bjDJ/PnaPIcmJCD+GAMgVGOX0fuESFuBlNfY7hABiQ0/dhEJeWZxCXlmcw9cqmyHD0NNA1YT5DRNcDlLIFwwEwRyCHBrJh6IYSazkugJEtYC48vW0qSgig5w5SAbqHVpQpMGI4AD14aAlgDhhwAAAbvoJXrYMiEwAAAABJRU5ErkJggg==";
const fireSprite = "" + new URL("Fire_Spreadsheet.png", import.meta.url).href;
const deathSprite = "data:image/png;base64,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";
const cobblestone = "" + new URL("cobblestone2.png", import.meta.url).href;
const bed = "" + new URL("bed.png", import.meta.url).href;
const flower = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAAXNSR0IArs4c6QAAAS9JREFUKFNFkT1OAzEQhd8UKFeApSQ1DZEQTbr1bAoKRE6w2gpxA7Yj3AClCuQABAmJIra3o4pEGkQJlCycIRSDxvZCY3v88+a9zwQQiACIIC0g0FpPwtRthzoOoHDAnItIFHDOERFBklAsICABDBuxS4vPRY3d8RWKEcM5TxSEJHkQgI2Rt7MtPG32oQLaZth7QX/6kx4kBxwUHdr7GuXsGfZiBZ4cYV4NsDOeoBgV8F47QNuzzKsDqNds+zr4VZ/t93lIU87W/5eZWay1aO9qlDdr2HqF4vIQt9UAmSoXBVzTqHcK4XJj5L3znJANe6/oTzdonA8hqAOnL0zOYt0SX4sa2Wmk4Z0niWz/EEf6gTNL5Ap4p60FEkNEZSIJ4SJNYO/hWD5OHsMv6W73lb8l6IsZYs2glgAAAABJRU5ErkJggg==";
class Sprite {
  constructor(sprites, config) {
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    this.sprites = sprites;
    this.config = config;
  }
  getLength() {
    return this.config.size;
  }
  getSpriteByIndex(index) {
    if (this.cache.has(index)) {
      return this.cache.get(index);
    }
    const { width, height } = this.sprites;
    const colWidth = width / this.config.cols;
    const rowHeight = height / this.config.rows;
    const canvas2 = document.createElement("canvas");
    canvas2.width = colWidth;
    canvas2.height = rowHeight;
    const canvasContext = canvas2.getContext("2d");
    canvasContext.imageSmoothingEnabled = false;
    const rowIndex = Math.floor(index / this.config.cols);
    const colIndex = index - rowIndex * this.config.cols;
    const xOffset = colIndex * colWidth;
    const yOffset = rowIndex * rowHeight;
    canvasContext.drawImage(
      this.sprites,
      xOffset,
      yOffset,
      colWidth,
      rowHeight,
      0,
      0,
      colWidth,
      rowHeight
    );
    const image = new Image();
    image.src = canvas2.toDataURL();
    this.cache.set(index, image);
    return image;
  }
}
class ResourceLoader {
  static getResourceCount() {
    const getCountRecursive = (o) => {
      return Object.entries(o).reduce((acc, [, value]) => {
        if (Array.isArray(value)) {
          return acc + 1;
        }
        if (typeof value === "object") {
          return acc + getCountRecursive(value);
        }
        return acc + 1;
      }, 0);
    };
    return getCountRecursive(this.rawAssets);
  }
  static getLoadedAssets() {
    return this.loadedAssets;
  }
  static flipImage(image, rect) {
    if (this.flippedImagesMap.has(image)) {
      return this.flippedImagesMap.get(image);
    }
    const canvas2 = document.createElement("canvas");
    canvas2.width = rect.width;
    canvas2.height = rect.height;
    const canvasContext = canvas2.getContext("2d");
    canvasContext.imageSmoothingEnabled = false;
    canvasContext.translate(rect.width, 0);
    canvasContext.scale(-1, 1);
    canvasContext.drawImage(image, 0, 0, rect.width, rect.height);
    const flippedImage = new Image();
    flippedImage.src = canvas2.toDataURL();
    this.flippedImagesMap.set(image, flippedImage);
    return flippedImage;
  }
  static async loadImage(src) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.src = src;
      image.onload = () => {
        resolve(image);
        this.flipImage(image, {
          width: image.width,
          height: image.height
        });
      };
      image.onerror = reject;
    });
  }
  static pattern(image, context) {
    if (this.patternMap.has(image)) {
      return this.patternMap.get(image);
    }
    const pattern = context.createPattern(image, "");
    this.patternMap.set(image, pattern);
    return pattern;
  }
  static compressSquareImage(image) {
    if (this.compressedImagesMap.has(image)) {
      return this.compressedImagesMap.get(image);
    }
    const canvas2 = document.createElement("canvas");
    canvas2.width = 100;
    canvas2.height = 100;
    const context = canvas2.getContext("2d");
    context.imageSmoothingEnabled = false;
    context.drawImage(image, 0, 0, 100, 100);
    const compressedImage = new Image();
    compressedImage.src = canvas2.toDataURL();
    this.compressedImagesMap.set(image, compressedImage);
    return compressedImage;
  }
  static getImageFromPattern(patternOrImage, width, height) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = width;
    canvas2.height = height;
    const context = canvas2.getContext("2d");
    let pattern;
    if (patternOrImage instanceof CanvasPattern) {
      pattern = patternOrImage;
    } else {
      pattern = this.pattern(patternOrImage, context);
    }
    context.imageSmoothingEnabled = false;
    context.fillStyle = pattern;
    context.fillRect(
      0,
      0,
      width,
      height
    );
    const image = new Image();
    image.src = canvas2.toDataURL();
    return image;
  }
  static async loadGameAssets() {
    const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
    const withLogging = async (name, fn) => {
      const delay = 10;
      await sleep(delay);
      this.emitter.emit("logs", { status: "loading", name });
      await fn();
      await sleep(delay);
      this.emitter.emit("logs", { status: "loaded", name });
      await sleep(delay);
    };
    await withLogging("adventurer.idle", async () => {
      this.loadedAssets.adventurer.idle = await Promise.all(this.rawAssets.adventurer.idle.map((src) => this.loadImage(src)));
    });
    await withLogging("adventurer.run", async () => {
      this.loadedAssets.adventurer.run = await Promise.all(this.rawAssets.adventurer.run.map((src) => this.loadImage(src)));
    });
    await withLogging("adventurer.attack1", async () => {
      this.loadedAssets.adventurer.attack1 = await Promise.all(this.rawAssets.adventurer.attack1.map((src) => this.loadImage(src)));
    });
    await withLogging("adventurer.die", async () => {
      this.loadedAssets.adventurer.die = await Promise.all(this.rawAssets.adventurer.die.map((src) => this.loadImage(src)));
    });
    await withLogging("adventurer.dead", async () => {
      this.loadedAssets.adventurer.dead = await Promise.all(this.rawAssets.adventurer.dead.map((src) => this.loadImage(src)));
    });
    await withLogging("slime.idle", async () => {
      this.loadedAssets.slime.idle = await Promise.all(this.rawAssets.slime.idle.map((src) => this.loadImage(src)));
    });
    await withLogging("slime.move", async () => {
      this.loadedAssets.slime.move = await Promise.all(this.rawAssets.slime.move.map((src) => this.loadImage(src)));
    });
    await withLogging("slime.die", async () => {
      this.loadedAssets.slime.die = await Promise.all(this.rawAssets.slime.die.map((src) => this.loadImage(src)));
    });
    await withLogging("slime.attack", async () => {
      this.loadedAssets.slime.attack = await Promise.all(this.rawAssets.slime.attack.map((src) => this.loadImage(src)));
    });
    await withLogging("flower", async () => {
      this.loadedAssets.flower = await this.loadImage(this.rawAssets.flower);
    });
    await withLogging("bed", async () => {
      this.loadedAssets.bed = await this.loadImage(this.rawAssets.bed);
    });
    await withLogging("cobblestone", async () => {
      this.loadedAssets.cobblestone = this.compressSquareImage(await this.loadImage(this.rawAssets.cobblestone));
    });
    await withLogging("fireSprite", async () => {
      this.loadedAssets.fireSprite = new Sprite(await this.loadImage(this.rawAssets.fireSprite), { cols: 2, rows: 2, size: 4 });
    });
    await withLogging("death.idle", async () => {
      this.loadedAssets.deathSprite = new Sprite(await this.loadImage(this.rawAssets.deathSprite), { cols: 4, rows: 1, size: 4 });
    });
    await withLogging("guard.idle", async () => {
      this.loadedAssets.guard.idle = new Sprite(await this.loadImage(this.rawAssets.guard.idle), { cols: 10, rows: 1, size: 10 });
    });
    await withLogging("guard.attack", async () => {
      this.loadedAssets.guard.attack = new Sprite(await this.loadImage(this.rawAssets.guard.attack), { cols: 4, rows: 1, size: 4 });
    });
    await withLogging("guard.run", async () => {
      this.loadedAssets.guard.run = new Sprite(await this.loadImage(this.rawAssets.guard.run), { cols: 6, rows: 1, size: 6 });
    });
    await withLogging("guard.death", async () => {
      this.loadedAssets.guard.death = new Sprite(await this.loadImage(this.rawAssets.guard.death), { cols: 9, rows: 1, size: 9 });
    });
  }
}
__publicField(ResourceLoader, "emitter", new EventEmitter());
__publicField(ResourceLoader, "rawAssets", {
  adventurer: {
    idle: [
      adventurerIdle00,
      adventurerIdle01,
      adventurerIdle02,
      adventurerIdle03
    ],
    run: [
      adventurerRun00,
      adventurerRun01,
      adventurerRun02,
      adventurerRun03,
      adventurerRun04,
      adventurerRun05
    ],
    attack1: [
      adventurerAttack_1_00,
      adventurerAttack_1_01,
      adventurerAttack_1_02,
      adventurerAttack_1_03,
      adventurerAttack_1_04
    ],
    die: [
      advendurerDie_0,
      advendurerDie_1,
      advendurerDie_2,
      advendurerDie_3,
      advendurerDie_4,
      advendurerDie_5,
      advendurerDie_6
    ],
    dead: [
      advendurerDie_5,
      advendurerDie_6
    ]
  },
  slime: {
    idle: [
      slimeIdle_0,
      slimeIdle_1,
      slimeIdle_2,
      slimeIdle_3
    ],
    attack: [
      slimeAttack_0,
      slimeAttack_1,
      slimeAttack_2,
      slimeAttack_3,
      slimeAttack_4
    ],
    move: [
      slimeMove_0,
      slimeMove_1,
      slimeMove_2,
      slimeMove_3
    ],
    die: [
      slimeDie_0,
      slimeDie_1,
      slimeDie_2,
      slimeDie_3
    ]
  },
  guard: {
    idle: guardIdle,
    attack: guardAttack,
    run: guardRun,
    death: guardDeath
  },
  fireSprite,
  deathSprite,
  flower,
  cobblestone,
  bed
});
__publicField(ResourceLoader, "loadedAssets", {
  adventurer: {
    idle: [],
    run: [],
    attack1: [],
    die: [],
    dead: []
  },
  slime: {
    idle: [],
    move: [],
    die: [],
    attack: []
  },
  guard: {
    idle: null,
    attack: null,
    run: null,
    death: null
  },
  fireSprite: null,
  deathSprite: null,
  flower: null,
  cobblestone: null,
  bed: null
});
__publicField(ResourceLoader, "flippedImagesMap", /* @__PURE__ */ new Map());
__publicField(ResourceLoader, "patternMap", /* @__PURE__ */ new Map());
__publicField(ResourceLoader, "compressedImagesMap", /* @__PURE__ */ new Map());
class Animator {
  constructor() {
    __publicField(this, "emitter", new EventEmitter());
    __publicField(this, "sprites", []);
    __publicField(this, "speed", 0);
    __publicField(this, "gameObject");
    __publicField(this, "currentAnimationId", 0);
    __publicField(this, "timeSpent", 0);
  }
  setSpeed(speed) {
    this.speed = speed;
  }
  setSprites(sprites) {
    this.sprites = sprites;
  }
  getGameObject() {
    return this.gameObject;
  }
  setGameObject(gameObject) {
    this.gameObject = gameObject;
  }
  getCurrentSprite() {
    const SPRITE_TIME_MS = 1e3 / this.speed;
    let length = 0;
    if (this.sprites instanceof Sprite) {
      length = this.sprites.getLength();
    } else {
      length = this.sprites.length;
    }
    if (this.timeSpent >= SPRITE_TIME_MS) {
      this.currentAnimationId++;
      if (this.currentAnimationId === length) {
        this.emitter.emit("animation_end", null);
      }
      this.currentAnimationId %= length;
      this.timeSpent = 0;
    }
    if (!this.gameObject || this.gameObject.isRightToLeft()) {
      if (this.sprites instanceof Sprite) {
        if (this.gameObject && this.gameObject.getRotation().isLeft()) {
          const box = this.gameObject.getBox();
          const rect = box.getRect();
          return ResourceLoader.flipImage(this.sprites.getSpriteByIndex(this.currentAnimationId), rect);
        }
        return this.sprites.getSpriteByIndex(this.currentAnimationId);
      } else {
        if (this.gameObject && this.gameObject.getRotation().isLeft()) {
          const box = this.gameObject.getBox();
          const rect = box.getRect();
          return ResourceLoader.flipImage(this.sprites[this.currentAnimationId], rect);
        }
        return this.sprites[this.currentAnimationId];
      }
    } else {
      if (this.sprites instanceof Sprite) {
        if (this.gameObject && this.gameObject.getRotation().isRight()) {
          const box = this.gameObject.getBox();
          const rect = box.getRect();
          return ResourceLoader.flipImage(this.sprites.getSpriteByIndex(this.currentAnimationId), rect);
        }
        return this.sprites.getSpriteByIndex(this.currentAnimationId);
      } else {
        if (this.gameObject && this.gameObject.getRotation().isRight()) {
          const box = this.gameObject.getBox();
          const rect = box.getRect();
          return ResourceLoader.flipImage(this.sprites[this.currentAnimationId], rect);
        }
        return this.sprites[this.currentAnimationId];
      }
    }
  }
  onAnimationEndOnce(subscriber) {
    return this.emitter.subscribe("animation_end", () => {
      subscriber();
    });
  }
  update(timeElapsed) {
    this.timeSpent += timeElapsed;
  }
}
class FiniteStateMachine {
  constructor() {
    __publicField(this, "emitter", new EventEmitter());
    __publicField(this, "state");
    __publicField(this, "states", {});
  }
  start() {
  }
  addState(name, fsmConstructor) {
    this.states[name] = fsmConstructor;
  }
  setState(NewStateConstructor) {
    const prevState = this.state;
    if (prevState && prevState.constructor.name !== NewStateConstructor.name) {
      this.state.onExit();
    }
    this.state = new NewStateConstructor(this);
    this.state.onEnter();
  }
  getCurrentState() {
    return this.state;
  }
  send(action) {
  }
  update(timeElapsed) {
    if (this.state) {
      this.state.update(timeElapsed);
    }
  }
}
class Rotation {
  constructor(value) {
    __publicField(this, "value", 0);
    this.value = value;
  }
  get() {
    return this.value;
  }
  set(val) {
    this.value = val;
  }
  isLeft() {
    const value = this.value % (Math.PI * 2);
    return Math.abs(value) > Math.PI / 2;
  }
  isRight() {
    return !this.isLeft();
  }
}
class GameObject {
  constructor(finiteStateMachine = new FiniteStateMachine()) {
    __publicField(this, "box");
    __publicField(this, "children", []);
    __publicField(this, "finiteStateMachine");
    __publicField(this, "rotation", new Rotation(123));
    __publicField(this, "collidable", false);
    __publicField(this, "color", null);
    __publicField(this, "patternImage", null);
    __publicField(this, "image", null);
    this.finiteStateMachine = finiteStateMachine;
  }
  getImage() {
    return this.image;
  }
  setImage(image) {
    this.image = image;
  }
  getPatternImage() {
    return this.patternImage;
  }
  setPatternImage(patternImage) {
    this.patternImage = patternImage;
  }
  getColor() {
    return this.color;
  }
  setColor(color) {
    this.color = color;
  }
  isCollidable() {
    return this.collidable;
  }
  setIsCollidable(value) {
    this.collidable = value;
  }
  isRightToLeft() {
    return true;
  }
  getBox() {
    return this.box;
  }
  setBox(box) {
    this.box = box;
  }
  getRotation() {
    return this.rotation;
  }
  setRotation(rotation) {
    if (rotation instanceof Rotation) {
      this.rotation = rotation;
    }
    if (typeof rotation === "number") {
      this.rotation.set(rotation);
    }
  }
  getAllTheBoxes() {
    const boxes = [];
    if (this.box) {
      boxes.push(this.box);
    }
    this.children.forEach((child) => {
      const childBoxes = child.getAllTheBoxes();
      childBoxes.forEach((box) => {
        boxes.push(box);
      });
    });
    return boxes;
  }
  getChildren() {
    return this.children;
  }
  getAllCollidables() {
    const result = [];
    if (this.isCollidable()) {
      result.push(this);
    }
    this.children.forEach((child) => {
      const collidable = child.getAllCollidables();
      collidable.forEach((grandChild) => {
        result.push(grandChild);
      });
    });
    return result;
  }
  addChild(child) {
    this.children.push(child);
  }
  removeChild(child) {
    this.children = this.children.filter((c) => c !== child);
  }
  update(timeElapsed) {
    this.finiteStateMachine.update(timeElapsed);
    this.getChildren().forEach((child) => {
      child.update(timeElapsed);
    });
  }
  getCurrentSprite() {
    var _a;
    return ((_a = this.finiteStateMachine.getCurrentState()) == null ? void 0 : _a.getCurrentSprite()) ?? null;
  }
  draw(context, camera) {
    if (this.box) {
      const relationalEntityCoordinates = camera.getRelativeCoordinates(this.box).getRect();
      const currentSprite = this.getCurrentSprite();
      if (this.color) {
        context.save();
        context.fillStyle = this.color;
        context.fillRect(
          relationalEntityCoordinates.left,
          relationalEntityCoordinates.top,
          relationalEntityCoordinates.width,
          relationalEntityCoordinates.height
        );
        context.restore();
      }
      if (this.patternImage) {
        const pattern = ResourceLoader.pattern(this.patternImage, context);
        context.save();
        context.fillStyle = pattern;
        context.fillRect(
          relationalEntityCoordinates.left,
          relationalEntityCoordinates.top,
          relationalEntityCoordinates.width,
          relationalEntityCoordinates.height
        );
        context.restore();
      }
      if (this.image) {
        context.drawImage(
          this.image,
          relationalEntityCoordinates.left,
          relationalEntityCoordinates.top,
          relationalEntityCoordinates.width,
          relationalEntityCoordinates.height
        );
      }
      if (currentSprite instanceof HTMLImageElement) {
        try {
          context.drawImage(
            currentSprite,
            relationalEntityCoordinates.left,
            relationalEntityCoordinates.top,
            relationalEntityCoordinates.width,
            relationalEntityCoordinates.height
          );
        } catch (error) {
          debugger;
        }
      }
    }
    this.getChildren().forEach((child) => {
      child.draw(context, camera);
    });
  }
}
class State {
  constructor(fsm) {
    __publicField(this, "fsm");
    __publicField(this, "animator", new Animator());
    __publicField(this, "sprites", []);
    __publicField(this, "speed", 0);
    __publicField(this, "gameObject");
    this.fsm = fsm;
    this.gameObject = new GameObject(fsm);
  }
  onEnter() {
    this.animator.setGameObject(this.gameObject);
    this.animator.setSprites(this.sprites);
    this.animator.setSpeed(this.speed);
  }
  onExit() {
  }
  getCurrentSprite() {
    return this.animator.getCurrentSprite();
  }
  update(timeElapsed) {
    this.animator.update(timeElapsed);
  }
}
const mainTheme = "" + new URL("ruapporangespace_Aim_To_Head_-_EMPeror_71070745.mp3", import.meta.url).href;
const swordAttack = "" + new URL("Sword Whooshes Medium - QuickSounds.com.mp3", import.meta.url).href;
const steps = "" + new URL("sneaker-shoe-on-concrete-floor-fast-pace-1-www.FesliyanStudios.com.mp3", import.meta.url).href;
const evilSlime = "" + new URL("evil-slime.mp3", import.meta.url).href;
const neutralSlime = "" + new URL("neutral-slime.mp3", import.meta.url).href;
const movingSlime = "" + new URL("moving-slime.mp3", import.meta.url).href;
const _MusicPlayer = class {
  constructor(audio) {
    __publicField(this, "audio");
    __publicField(this, "isPlaying", false);
    this.audio = audio;
  }
  static getIsStepsPlaying() {
    return this.isStepsPlaying;
  }
  static getIsPlaying() {
    return this.isPlaying;
  }
  static playMainTheme() {
    this.currentTrack = this.createAudio(mainTheme, { loop: true, volume: 0.04 });
    this.play();
  }
  static playSteps() {
    if (this.getIsStepsPlaying()) {
      return;
    }
    this.steps = this.createAudio(steps, { loop: true, volume: 0.3 });
    this.steps.play();
  }
  static pausePlayingSteps() {
    if (!this.steps) {
      console.error("steps is not loaded. cannot play");
      return;
    }
    this.steps.pause();
  }
  static playAttackOnce() {
    const zap = this.createAudio(swordAttack, { loop: false, volume: 0.04 });
    zap.addEventListener("timeupdate", function() {
      const currentTime = zap.currentTime;
      if (currentTime > 1) {
        zap.pause();
      }
    });
    zap.play();
  }
  static pause() {
    if (!this.currentTrack) {
      console.error("Trying to call pause when there is no currentTrack!");
      return;
    }
    if (!this.isPlaying) {
      return;
    }
    this.isPlaying = false;
    this.currentTrack.pause();
  }
  static play() {
    if (!this.currentTrack) {
      console.error("Trying to call play when there is no currentTrack!");
      return;
    }
    if (this.isPlaying) {
      return;
    }
    this.isPlaying = true;
    this.currentTrack.play();
  }
  static createAudio(src, options) {
    const audio = document.createElement("audio");
    audio.volume = options.volume || 0.5;
    audio.loop = options.loop;
    audio.src = src;
    return audio;
  }
  static createPlayer(src, options) {
    return new _MusicPlayer(this.createAudio(src, options));
  }
  static createSlimeMovingPlayer() {
    return this.createPlayer(movingSlime, { loop: true, volume: 1e-3 });
  }
  static createEvilSlimePlayer() {
    return this.createPlayer(evilSlime, { loop: true, volume: 2e-3 });
  }
  static createNeutralSlimePlayer() {
    return this.createPlayer(neutralSlime, { loop: true, volume: 1e-3 });
  }
  play() {
    if (this.isPlaying) {
      return;
    }
    this.audio.play();
    this.isPlaying = true;
  }
  pause() {
    if (!this.isPlaying) {
      return;
    }
    this.audio.pause();
    this.isPlaying = false;
  }
  setVolume(volume) {
    this.audio.volume = volume;
  }
  tuneSoundByDistance(distance) {
    const MAX_DISTANCE = 400;
    if (distance > MAX_DISTANCE) {
      this.setVolume(0);
    } else {
      const MAX_VOLUME = 0.3;
      const volume = MAX_VOLUME - distance / MAX_DISTANCE * MAX_VOLUME;
      this.setVolume(volume);
    }
  }
};
let MusicPlayer = _MusicPlayer;
__publicField(MusicPlayer, "currentTrack");
__publicField(MusicPlayer, "steps");
__publicField(MusicPlayer, "isStepsPlaying", false);
__publicField(MusicPlayer, "isPlaying", false);
class PlayerIdleState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().adventurer.idle);
    __publicField(this, "speed", 5);
    __publicField(this, "fsm");
    this.fsm = fsm;
    this.gameObject = this.fsm.getPlayer().getGameObject();
  }
  onEnter() {
    super.onEnter();
  }
  onExit() {
    super.onExit();
  }
  update(timeElapsed) {
    var _a, _b;
    super.update(timeElapsed);
    if ((_a = this.fsm.getPlayer().getInputController()) == null ? void 0 : _a.isAttack1Pressed()) {
      return this.fsm.setState(PlayerAttackState);
    }
    if ((_b = this.fsm.getPlayer().getInputController()) == null ? void 0 : _b.isOneOfMovementKeysIsPressed()) {
      return this.fsm.setState(PlayerRunState);
    }
  }
}
class PlayerRunState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().adventurer.run);
    __publicField(this, "speed", 5);
    __publicField(this, "fsm");
    this.fsm = fsm;
    this.gameObject = fsm.getPlayer().getGameObject();
  }
  onEnter() {
    super.onEnter();
    MusicPlayer.playSteps();
  }
  onExit() {
    super.onExit();
    MusicPlayer.pausePlayingSteps();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const inputController = this.fsm.getInputController();
    if (!inputController) {
      return;
    }
    if (!(inputController == null ? void 0 : inputController.isOneOfMovementKeysIsPressed())) {
      this.fsm.setState(PlayerIdleState);
    } else {
      const length = this.fsm.getPlayer().getSpeed() * timeElapsed / 1e3;
      let x = 0;
      let y = 0;
      if (inputController.isTopPressed()) {
        y -= length;
      }
      if (inputController.isRightPressed()) {
        x += length;
      }
      if (inputController.isBottomPressed()) {
        y += length;
      }
      if (inputController.isLeftPressed()) {
        x -= length;
      }
      const player = this.fsm.getPlayer();
      const playerBox = player.getGameObject().getBox();
      const nextBox = playerBox.copy();
      nextBox.move(x, y);
      document.getElementById("playerPos").innerHTML = `player center x ${nextBox.getCenter().x} y ${nextBox.getCenter().y} <br />`;
      document.getElementById("playerPos").innerHTML += `player topleft x ${nextBox.getTopLeft().x} y ${nextBox.getTopLeft().y}`;
      const collisions = this.fsm.getPlayer().findCollisions(nextBox);
      if (collisions.length === 0) {
        const angle = Math.atan2(y, x);
        if (Math.abs(angle) !== Math.PI / 2) {
          player.getGameObject().setRotation(angle);
        }
        playerBox.move(x, y);
        player.emitter.emit("player_move", playerBox);
      }
    }
  }
}
class PlayerAttackState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().adventurer.attack1);
    __publicField(this, "speed", 20);
    __publicField(this, "fsm");
    __publicField(this, "player");
    __publicField(this, "unsubscribeFromAnimationEnd", null);
    this.fsm = fsm;
    this.gameObject = this.fsm.getPlayer().getGameObject();
    this.player = this.fsm.getPlayer();
  }
  onEnter() {
    super.onEnter();
    MusicPlayer.playAttackOnce();
    this.unsubscribeFromAnimationEnd = this.animator.onAnimationEndOnce(() => {
      this.fsm.setState(PlayerIdleState);
    });
  }
  onExit() {
    super.onExit();
    if (this.unsubscribeFromAnimationEnd) {
      this.unsubscribeFromAnimationEnd();
    }
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const gameMap = this.fsm.getPlayer().getEntityManager().getEntityByName("map");
    const entities = gameMap.findEntities(this.player.getGameObject().getBox().getCenter(), this.player.getAttackRange()).filter((entity) => entity !== this.player).filter((entity) => !!entity.getHealth).filter((entity) => entity.getHealth().getValue() > 0);
    const damage = this.player.getAttackDamage() * this.player.getAttackSpeed() * (timeElapsed / 1e3);
    entities.forEach((e) => {
      e.damage(damage, this.player);
    });
  }
}
class PlayerDieState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().adventurer.die);
    __publicField(this, "speed", 5);
    __publicField(this, "fsm");
    __publicField(this, "unsubscribeFromAnimationEnd", null);
    this.fsm = fsm;
    this.gameObject = this.fsm.getPlayer().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.unsubscribeFromAnimationEnd = this.animator.onAnimationEndOnce(() => {
      this.fsm.setState(PlayerDeadState);
    });
  }
  onExit() {
    super.onExit();
    if (this.unsubscribeFromAnimationEnd) {
      this.unsubscribeFromAnimationEnd();
    }
  }
}
class PlayerDeadState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().adventurer.dead.slice(0, 1));
    __publicField(this, "speed", 1);
    __publicField(this, "fsm");
    this.fsm = fsm;
    this.gameObject = this.fsm.getPlayer().getGameObject();
  }
}
class PlayerFiniteStateMachine extends FiniteStateMachine {
  constructor(player) {
    super();
    __publicField(this, "player");
    __publicField(this, "inputController");
    this.player = player;
    this.setState(PlayerIdleState);
  }
  getPlayer() {
    return this.player;
  }
  getInputController() {
    return this.inputController;
  }
  onEntityInit() {
    this.inputController = this.player.getInputController();
  }
  onAction(_) {
  }
  update(timeElapsed) {
    super.update(timeElapsed);
  }
}
class Position {
  constructor(x, y, z) {
    __publicField(this, "pos", [0, 0, 0]);
    this.x = x;
    this.y = y;
    this.z = z;
  }
  get x() {
    return this.pos[0];
  }
  set x(val) {
    this.pos[0] = val;
  }
  get y() {
    return this.pos[1];
  }
  set y(val) {
    this.pos[1] = val;
  }
  get z() {
    return this.pos[2];
  }
  set z(val) {
    this.pos[2] = val;
  }
  toArray() {
    return [...this.pos];
  }
  copy() {
    return new Position(this.pos[0], this.pos[1], this.pos[2]);
  }
  getAngle(pos) {
    return Math.atan2(this.y - pos.y, this.x - pos.x);
  }
  distance(pos) {
    return Math.sqrt(Math.pow(this.x - pos.x, 2) + Math.pow(this.y - pos.y, 2));
  }
  getVector(pos) {
    const copy = this.copy();
    copy.x = this.x - pos.x;
    copy.y = this.y - pos.y;
    return copy;
  }
  addVector(pos) {
    this.x += pos.x;
    this.y += pos.y;
  }
}
class Box {
  constructor(topLeft, width, height) {
    this.topLeft = topLeft;
    this.width = width;
    this.height = height;
  }
  getTopLeft() {
    return this.topLeft;
  }
  setTopLeft(position) {
    this.topLeft = position;
  }
  getWidth() {
    return this.width;
  }
  setWidth(width) {
    this.width = width;
  }
  getHeight() {
    return this.height;
  }
  setHeight(height) {
    this.height = height;
  }
  getRect() {
    const top = this.topLeft.y;
    const left = this.topLeft.x;
    const right = this.topLeft.x + this.width;
    const bottom = this.topLeft.y + this.height;
    const width = right - left;
    const height = bottom - top;
    return {
      top,
      left,
      right,
      bottom,
      width,
      height
    };
  }
  calculateRelationRect(box) {
    const selfRect = this.getRect();
    const boxRect = box.getRect();
    return {
      left: boxRect.left - selfRect.left,
      bottom: boxRect.bottom - selfRect.bottom,
      right: boxRect.right - selfRect.right,
      top: boxRect.top - selfRect.top,
      width: boxRect.width,
      height: boxRect.height
    };
  }
  move(x, y) {
    this.topLeft.x += x;
    this.topLeft.y += y;
  }
  // public setCenter(newCenter: Position): void {
  //   const currentCenter = this.getCenter();
  //   const dx = newCenter.x - currentCenter.x;
  //   const dy = newCenter.y - currentCenter.y;
  //
  //   this.p1.x += dx;
  //   this.p1.y += dy;
  //
  //   this.p2.x += dx;
  //   this.p2.y += dy;
  // }
  copy() {
    return new Box(
      this.topLeft.copy(),
      this.width,
      this.height
    );
  }
  getCenter() {
    const rect = this.getRect();
    const x = rect.left + rect.width / 2;
    const y = rect.top + rect.height / 2;
    return new Position(x, y, 0);
  }
  isCollide(box) {
    const a = this.getRect();
    const b = box.getRect();
    return !(a.top + a.height < b.top || a.top > b.top + b.height || a.left + a.width < b.left || a.left > b.left + b.width);
  }
}
class Random {
  static runChance(timeSEC, chanceSEC) {
    return Math.random() < 1 - Math.pow(1 - chanceSEC, timeSEC);
  }
}
class EnemyIdleState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.idle);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createNeutralSlimePlayer());
    __publicField(this, "chanceToHangAround", 0.1);
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.player.play();
  }
  onExit() {
    super.onExit();
    this.player.pause();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const currentPlayer = this.fsm.getEnemy().getEntityManager().getEntityByName("player");
    const distance = this.fsm.getEnemy().getGameObject().getBox().getCenter().distance(currentPlayer.getGameObject().getBox().getCenter());
    this.player.tuneSoundByDistance(distance);
    const gameMap = this.fsm.getEnemy().getEntityManager().getEntityByName("map");
    const players = gameMap.findEntities(this.fsm.getEnemy().getGameObject().getBox().getCenter(), 200).filter((e) => e instanceof PlayerEntity).filter((player) => player.getHealth().getValue() > 0);
    if (players.length > 0) {
      this.fsm.setState(EnemyChasingPlayerState);
    } else {
      if (Random.runChance(timeElapsed / 1e3, this.chanceToHangAround)) {
        this.fsm.setState(EnemyHangingAroundState);
      }
    }
  }
}
class EnemyHangingAroundState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.move);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createNeutralSlimePlayer());
    __publicField(this, "chanceToStay", 0.1);
    __publicField(this, "rotation", new Rotation(0));
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.rotation = new Rotation(Math.random() * 2 * Math.PI);
  }
  onExit() {
    super.onExit();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    this.fsm.getEnemy().getGameObject().setRotation(this.rotation.get());
    const speed = this.fsm.getEnemy().getSpeed();
    const dy = timeElapsed * (Math.sin(this.rotation.get()) * speed);
    const dx = timeElapsed * (Math.cos(this.rotation.get()) * speed);
    const nextBox = this.fsm.getEnemy().getGameObject().getBox().copy();
    nextBox.move(dx, dy);
    const collisions = this.fsm.getEnemy().findCollisions(nextBox);
    if (!collisions.length) {
      this.fsm.getEnemy().getGameObject().getBox().move(dx, dy);
    } else {
      this.fsm.setState(EnemyIdleState);
    }
    if (Random.runChance(timeElapsed / 1e3, this.chanceToStay)) {
      this.fsm.setState(EnemyIdleState);
    }
  }
}
class EnemyChasingPlayerState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.move);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createSlimeMovingPlayer());
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.player.play();
  }
  onExit() {
    super.onExit();
    this.player.pause();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const currentPlayer = this.fsm.getEnemy().getEntityManager().getEntityByName("player");
    const distance = this.fsm.getEnemy().getGameObject().getBox().getCenter().distance(currentPlayer.getGameObject().getBox().getCenter());
    this.player.tuneSoundByDistance(distance);
    const gameMap = this.fsm.getEnemy().getEntityManager().getEntityByName("map");
    const players = gameMap.findEntities(this.fsm.getEnemy().getGameObject().getBox().getCenter(), this.fsm.getEnemy().getReactDistance()).filter((e) => e instanceof PlayerEntity);
    if (players.length > 0) {
      const playerToChaise = players[0];
      const distanceToPlayer = playerToChaise.getGameObject().getBox().getCenter().distance(this.fsm.getEnemy().getGameObject().getBox().getCenter());
      if (distanceToPlayer > this.fsm.getEnemy().getAttackRange()) {
        const playerCenterPosition = playerToChaise.getGameObject().getBox().getCenter();
        const enemyCenterPosition = this.fsm.getEnemy().getGameObject().getBox().getCenter();
        const angle = playerCenterPosition.getAngle(enemyCenterPosition);
        this.fsm.getEnemy().getGameObject().setRotation(angle);
        const speed = this.fsm.getEnemy().getSpeed();
        const dy = timeElapsed * (Math.sin(angle) * speed);
        const dx = timeElapsed * (Math.cos(angle) * speed);
        this.fsm.getEnemy().getGameObject().getBox().move(dx, dy);
      } else {
        this.fsm.setState(EnemyAttackPlayerState);
      }
    } else {
      this.fsm.setState(EnemyIdleState);
    }
  }
}
class EnemyAttackPlayerState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.attack);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createEvilSlimePlayer());
    __publicField(this, "enemy");
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
    this.enemy = this.fsm.getEnemy();
  }
  onEnter() {
    super.onEnter();
    this.player.play();
  }
  onExit() {
    super.onExit();
    this.player.pause();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const currentPlayer = this.fsm.getEnemy().getEntityManager().getEntityByName("player");
    const distance = this.fsm.getEnemy().getGameObject().getBox().getCenter().distance(currentPlayer.getGameObject().getBox().getCenter());
    this.player.tuneSoundByDistance(distance);
    const gameMap = this.fsm.getEnemy().getEntityManager().getEntityByName("map");
    const players = gameMap.findEntities(this.fsm.getEnemy().getGameObject().getBox().getCenter(), this.fsm.getEnemy().getReactDistance()).filter((e) => e instanceof PlayerEntity).filter((player2) => player2.getHealth().getValue() > 0);
    const player = players.length ? players[0] : null;
    if (!player) {
      this.fsm.setState(EnemyIdleState);
    } else {
      const damage = this.enemy.getAttackDamage() * this.enemy.getAttackSpeed() * (timeElapsed / 1e3);
      player.damage(damage);
      if (player.getGameObject().getBox().getCenter().distance(this.fsm.getEnemy().getGameObject().getBox().getCenter()) > this.fsm.getEnemy().getAttackRange()) {
        this.fsm.setState(EnemyChasingPlayerState);
      }
    }
  }
}
class AttackCircle extends GameObject {
  constructor(parent, finiteStateMachine, radius) {
    super(finiteStateMachine);
    __publicField(this, "parent");
    this.radius = radius;
    this.parent = parent;
  }
  draw(context, camera) {
    if (this.finiteStateMachine.getCurrentState() instanceof PlayerAttackState || this.finiteStateMachine.getCurrentState() instanceof EnemyAttackPlayerState) {
      const parentCenter = this.parent.getBox().getCenter();
      const relativePosition = camera.getRelativePosition(parentCenter);
      context.save();
      context.beginPath();
      context.strokeStyle = "#ff0000";
      context.arc(relativePosition.x, relativePosition.y, this.radius, 0, 2 * Math.PI);
      context.stroke();
      context.restore();
    }
  }
}
class HealthBar extends GameObject {
  constructor(entityWithHealth) {
    super();
    __publicField(this, "entityWithHealth");
    this.entityWithHealth = entityWithHealth;
  }
  draw(context, camera) {
    const parentRelativeBox = camera.getRelativeCoordinates(this.entityWithHealth.getGameObject().getBox());
    const parentRelativeRect = parentRelativeBox.getRect();
    const health = this.entityWithHealth.getHealth();
    const percent = health.getPercent();
    const WIDTH = 100;
    const HEIGHT = 10;
    const processedHealth = Math.ceil(health.getValue());
    const toDraw = processedHealth === 0 ? "" : processedHealth;
    context.save();
    context.fillStyle = "rgba(152,0,0,0.57)";
    context.fillRect(parentRelativeRect.left, parentRelativeRect.top, WIDTH * percent > WIDTH ? WIDTH : WIDTH * percent, HEIGHT);
    context.strokeStyle = processedHealth === 0 ? "rgba(215,215,215,0.73)" : "rgba(255,0,0,0.51)";
    context.beginPath();
    context.rect(parentRelativeRect.left, parentRelativeRect.top, WIDTH, HEIGHT);
    context.stroke();
    context.fillStyle = "#ffffff";
    context.font = "10px sans-serif";
    context.fillText(toDraw.toString(), parentRelativeRect.left, parentRelativeRect.top + 9);
    context.restore();
  }
}
class CharacterGameObject extends GameObject {
  constructor(x, y, player, finiteStateMachine) {
    super(finiteStateMachine);
    __publicField(this, "player");
    __publicField(this, "attackCircle");
    __publicField(this, "healthBar");
    this.player = player;
    this.box = new Box(
      new Position(x, y, 0),
      100,
      100
    );
    this.rotation = new Rotation(0);
    this.attackCircle = new AttackCircle(this, this.finiteStateMachine, this.player.getAttackRange());
    this.addChild(this.attackCircle);
    this.healthBar = new HealthBar(this.player);
    this.addChild(this.healthBar);
  }
}
class Health {
  constructor(value, maxValue) {
    this.value = value;
    this.maxValue = maxValue;
  }
  getValue() {
    return this.value;
  }
  setValue(value) {
    this.value = value;
  }
  getMaxValue() {
    return this.maxValue;
  }
  setMaxValue(maxValue) {
    this.maxValue = maxValue;
  }
  getPercent() {
    return this.value / this.maxValue;
  }
}
class DrawableEntity extends Entity {
  constructor() {
    super(...arguments);
    __publicField(this, "gameObject");
  }
  getGameObject() {
    return this.gameObject;
  }
  setGameObject(gameObject) {
    this.gameObject = gameObject;
  }
  findCollisions(boxToFindCollisionsWith) {
    const gameMap = this.getEntityManager().getEntityByName("map");
    const collidableGameObjects = gameMap.getCollidableGameObjects().filter((obj) => obj !== this.getGameObject());
    return collidableGameObjects.filter((gameObject) => {
      return boxToFindCollisionsWith.isCollide(gameObject.getBox());
    });
  }
  distance(entity) {
    return this.getGameObject().getBox().getTopLeft().distance(
      entity.getGameObject().getBox().getTopLeft()
    );
  }
}
class PlayerEntity extends DrawableEntity {
  constructor(x, y) {
    super();
    __publicField(this, "finiteStateMachine");
    __publicField(this, "inputController");
    __publicField(this, "health", new Health(100, 150));
    __publicField(this, "attackSpeed", 15);
    __publicField(this, "attackDamage", 20);
    __publicField(this, "attackRange", 65);
    __publicField(this, "speed", 180);
    __publicField(this, "COLOR", "rgba(255,0,98,0)");
    __publicField(this, "unsubscribeFromSpeedChange");
    this.finiteStateMachine = new PlayerFiniteStateMachine(this);
    this.gameObject = new CharacterGameObject(x, y, this, this.finiteStateMachine);
  }
  getFiniteStateMachine() {
    return this.finiteStateMachine;
  }
  getInputController() {
    return this.inputController;
  }
  getHealth() {
    return this.health;
  }
  setHealth(value) {
    this.health.setValue(value);
  }
  damage(value) {
    let newHealth = this.getHealth().getValue() - value;
    if (newHealth <= 0) {
      newHealth = 0;
      this.finiteStateMachine.setState(PlayerDieState);
      this.getEntityManager().getEntityByName("ui").showModal({
        title: "ПОРАЖЕНИЕ",
        body: "О НЕТ! ПОСЛЕДНЯЯ НАДЕЖДА ИМПЕРИИ ПАЛА. ВЕСЬ МИР ВЗОРВАЛСЯ И ВСЕ УМЕРЛИ"
      });
    }
    this.setHealth(newHealth);
  }
  getAttackSpeed() {
    return this.attackSpeed;
  }
  setAttackSpeed(value) {
    this.attackSpeed = value;
  }
  getAttackDamage() {
    return this.attackDamage;
  }
  setAttackDamage(value) {
    this.attackDamage = value;
  }
  getAttackRange() {
    return this.attackRange;
  }
  setAttackRange(value) {
    this.attackRange = value;
  }
  getSpeed() {
    return this.speed;
  }
  initEntity() {
    console.log("init player entity");
    this.inputController = this.getComponentByName("InputController");
    console.log("input controller", this.inputController);
    this.unsubscribeFromSpeedChange = this.emitter.subscribe("speed_change", (value) => {
      this.speed = value;
    });
    this.emitter.subscribe("attack_speed_change", (value) => {
      this.attackSpeed = value;
    });
    this.finiteStateMachine.onEntityInit();
    super.initEntity();
  }
  destroy() {
    super.destroy();
    this.unsubscribeFromSpeedChange();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    this.finiteStateMachine.update(timeElapsed);
  }
}
class InputController extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "pressedKeys", /* @__PURE__ */ new Map());
    __publicField(this, "keyDownHandler", (event) => {
      this.pressedKeys.set(event.code, true);
    });
    __publicField(this, "keyUpHandler", (event) => {
      this.pressedKeys.set(event.code, false);
    });
    __publicField(this, "windowFocusOutHandler", () => {
      this.pressedKeys.forEach((_, key) => {
        this.pressedKeys.set(key, false);
      });
    });
  }
  isOneOfMovementKeysIsPressed() {
    return this.isTopPressed() || this.isRightPressed() || this.isBottomPressed() || this.isLeftPressed();
  }
  isTopPressed() {
    return !!this.pressedKeys.get("KeyW") || !!this.pressedKeys.get("ArrowUp");
  }
  isRightPressed() {
    return !!this.pressedKeys.get("KeyD") || !!this.pressedKeys.get("ArrowRight");
  }
  isBottomPressed() {
    return !!this.pressedKeys.get("KeyS") || !!this.pressedKeys.get("ArrowDown");
  }
  isLeftPressed() {
    return !!this.pressedKeys.get("KeyA") || !!this.pressedKeys.get("ArrowLeft");
  }
  isAttack1Pressed() {
    return !!this.pressedKeys.get("KeyE");
  }
  init() {
    super.init();
    document.addEventListener("keydown", this.keyDownHandler);
    Array.from(document.querySelectorAll("#mobile-controls [data-key]")).forEach((div) => {
      div.addEventListener("mousedown", () => {
        this.pressedKeys.set(div.getAttribute("data-key"), true);
      });
      div.addEventListener("mouseup", () => {
        this.pressedKeys.set(div.getAttribute("data-key"), false);
      });
      div.addEventListener("touchstart", () => {
        this.pressedKeys.set(div.getAttribute("data-key"), true);
      });
      div.addEventListener("touchend", () => {
        this.pressedKeys.set(div.getAttribute("data-key"), false);
      });
    });
    document.addEventListener("keyup", this.keyUpHandler);
    document.addEventListener("focusout", this.windowFocusOutHandler);
  }
  destroy() {
    super.destroy();
    document.removeEventListener("keydown", this.keyDownHandler);
    document.removeEventListener("keyup", this.keyUpHandler);
    document.removeEventListener("focusout", this.windowFocusOutHandler);
  }
  update(timeElapsed) {
    super.update(timeElapsed);
  }
}
const _GameMap = class extends Entity {
  constructor(scene) {
    super();
    __publicField(this, "scene");
    this.scene = scene;
  }
  add(entity) {
    this.scene.entities.push(entity);
  }
  findEntities(point, maxDistance = _GameMap.MAX_DISTANCE) {
    return this.scene.entities.filter((entity) => {
      var _a, _b, _c;
      const center = (_c = (_b = (_a = entity.getGameObject) == null ? void 0 : _a.call(entity)) == null ? void 0 : _b.getBox()) == null ? void 0 : _c.getCenter();
      if (!center) {
        return false;
      }
      const distance = Math.sqrt((center.x - point.x) ** 2 + (center.y - point.y) ** 2);
      return distance <= maxDistance;
    });
  }
  getCollidableGameObjects() {
    return this.scene.entities.reduce((result, entity) => {
      if (!entity.getGameObject) {
        return result;
      }
      const gameObject = entity.getGameObject();
      const collidable = gameObject.getAllCollidables();
      collidable.forEach((c) => {
        result.push(c);
      });
      return result;
    }, []);
  }
};
let GameMap = _GameMap;
__publicField(GameMap, "MAX_DISTANCE", Infinity);
class MapWall extends DrawableEntity {
  // protected color = '#000';
  constructor(width, height) {
    super();
    __publicField(this, "gameObject");
    this.width = width;
    this.height = height;
    this.gameObject = new GameObject();
    this.setUpWalls();
  }
  setUpWalls() {
    const wallColor = "#493420";
    const floor = new GameObject();
    floor.setBox(new Box(
      new Position(0, 0, 0),
      this.width,
      this.height
    ));
    floor.setImage(ResourceLoader.getImageFromPattern(ResourceLoader.getLoadedAssets().cobblestone, this.width, this.height));
    floor.setIsCollidable(false);
    this.gameObject.addChild(floor);
    const leftWall = new GameObject();
    leftWall.setBox(new Box(
      new Position(0, 0, 0),
      20,
      this.height
    ));
    leftWall.setColor(wallColor);
    leftWall.setIsCollidable(true);
    this.gameObject.addChild(leftWall);
    const rightWall = new GameObject();
    rightWall.setBox(new Box(
      new Position(this.width - 20, 0, 0),
      20,
      this.height / 2 - 100
    ));
    rightWall.setColor(wallColor);
    rightWall.setIsCollidable(true);
    this.gameObject.addChild(rightWall);
    const rightWall2 = new GameObject();
    rightWall2.setBox(new Box(
      new Position(this.width - 20, this.height / 2 + 100, 0),
      20,
      this.height / 2 - 100
    ));
    rightWall2.setColor(wallColor);
    rightWall2.setIsCollidable(true);
    this.gameObject.addChild(rightWall2);
    const topWall = new GameObject();
    topWall.setBox(new Box(
      new Position(0, 0, 0),
      this.width,
      20
    ));
    topWall.setColor(wallColor);
    topWall.setIsCollidable(true);
    this.gameObject.addChild(topWall);
    const bottomWall = new GameObject();
    bottomWall.setBox(new Box(
      new Position(0, this.height - 20, 0),
      this.width,
      20
    ));
    bottomWall.setColor(wallColor);
    bottomWall.setIsCollidable(true);
    this.gameObject.addChild(bottomWall);
  }
  getGameObject() {
    return this.gameObject;
  }
}
class Camera extends Entity {
  constructor(width, height) {
    super();
    __publicField(this, "box");
    __publicField(this, "filter", "");
    this.box = new Box(
      new Position(0, 0, 0),
      width,
      height
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    this.filter = value;
  }
  getBox() {
    return this.box;
  }
  setBox(box) {
    this.box = box;
  }
  isVisibleBox(box) {
    return this.box.isCollide(box);
  }
  isVisibleGameObject(gameObject) {
    const boxes = gameObject.getAllTheBoxes();
    for (let i = 0; i < boxes.length; i++) {
      if (this.isVisibleBox(boxes[i])) {
        return true;
      }
    }
    return false;
  }
  isVisibleDrawableEntity(drawable) {
    return this.isVisibleGameObject(drawable.getGameObject());
  }
  getRelativePosition(position) {
    const copy = position.copy();
    const rect = this.box.getRect();
    copy.x -= rect.left;
    copy.y -= rect.top;
    return copy;
  }
  getRelativeCoordinates(box) {
    const copy = box.copy();
    const copyTopLeft = copy.getTopLeft();
    const cameraTopLeft = this.box.getTopLeft();
    copyTopLeft.x -= cameraTopLeft.x;
    copyTopLeft.y -= cameraTopLeft.y;
    return copy;
  }
}
class FollowPlayerCamera extends Camera {
  constructor(width, height, player) {
    super(width, height);
    __publicField(this, "unsubscribeFromPlayerMoveEventFn", null);
    this.player = player;
  }
  syncWithPlayer() {
    this.getBox().getRect();
    const topLeft = this.getBox().getTopLeft();
    const playerCenter = this.player.getGameObject().getBox().getCenter();
    topLeft.x = playerCenter.x - window.innerWidth / 2;
    topLeft.y = playerCenter.y - window.innerHeight / 2;
  }
  initEntity() {
    super.initEntity();
    this.syncWithPlayer();
    this.unsubscribeFromPlayerMoveEventFn = this.player.emitter.subscribe("player_move", (newPlayerBox) => {
      this.syncWithPlayer();
      document.getElementById("cameraPos").innerHTML = `camera center x ${this.getBox().getCenter().x} y ${this.getBox().getCenter().y} <br />`;
      document.getElementById("cameraPos").innerHTML += `camera corner x ${this.getBox().getRect().left} y ${this.getBox().getRect().top} <br />`;
    });
  }
  destroy() {
    super.destroy();
    if (this.unsubscribeFromPlayerMoveEventFn) {
      this.unsubscribeFromPlayerMoveEventFn();
    }
  }
}
class BedEntity extends DrawableEntity {
  // protected color = '#000';
  constructor() {
    super();
    __publicField(this, "gameObject");
    __publicField(this, "healed", false);
    this.gameObject = new GameObject();
    this.setUp();
  }
  setUp() {
    const image = ResourceLoader.getLoadedAssets().bed;
    const bed2 = new GameObject();
    bed2.setBox(new Box(
      new Position(20, 490, 0),
      140,
      70
    ));
    bed2.setImage(image);
    bed2.setIsCollidable(true);
    this.gameObject.addChild(bed2);
  }
  getGameObject() {
    return this.gameObject;
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    if (!this.healed) {
      const player = this.getEntityManager().getEntityByName("player");
      const selfTopLeft = this.gameObject.getChildren()[0].getBox().getTopLeft();
      const playerTopLeft = player.getGameObject().getBox().getTopLeft();
      if (!selfTopLeft || !playerTopLeft) {
        return;
      }
      const distanceToPlayer = selfTopLeft.distance(playerTopLeft);
      if (distanceToPlayer < 150) {
        player.setHealth(1e3);
        this.healed = true;
        const uiEntity = this.getEntityManager().getEntityByName("ui");
        uiEntity.showModal({
          title: "You were healed!",
          body: ""
        });
      }
    }
  }
}
class BaseEnemyGameObject extends GameObject {
  constructor(x, y, enemy, finiteStateMachine) {
    super(finiteStateMachine);
    __publicField(this, "enemy");
    __publicField(this, "attackCircle");
    __publicField(this, "healthBar");
    this.enemy = enemy;
    this.box = new Box(
      new Position(x, y, 0),
      100,
      100
    );
    this.rotation = new Rotation(123);
    this.attackCircle = new AttackCircle(this, this.finiteStateMachine, this.enemy.getAttackRange());
    this.addChild(this.attackCircle);
    this.healthBar = new HealthBar(this.enemy);
    this.addChild(this.healthBar);
  }
  isRightToLeft() {
    return false;
  }
}
class BaseEnemyIdleState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.idle);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createNeutralSlimePlayer());
    __publicField(this, "chanceToHangAround", 0.1);
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.player.play();
  }
  onExit() {
    super.onExit();
    this.player.pause();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const currentPlayer = this.fsm.getEnemy().getEntityManager().getEntityByName("player");
    const distance = this.fsm.getEnemy().getGameObject().getBox().getCenter().distance(currentPlayer.getGameObject().getBox().getCenter());
    this.player.tuneSoundByDistance(distance);
    const gameMap = this.fsm.getEnemy().getEntityManager().getEntityByName("map");
    const players = gameMap.findEntities(this.fsm.getEnemy().getGameObject().getBox().getCenter(), 200).filter((e) => e instanceof PlayerEntity).filter((player) => player.getHealth().getValue() > 0);
    if (players.length > 0) {
      this.fsm.setChasingPlayerState();
    } else {
      if (Random.runChance(timeElapsed / 1e3, this.chanceToHangAround)) {
        this.fsm.setHangingAroundState();
      }
    }
  }
}
class BaseEnemyHangingAroundState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.run);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createNeutralSlimePlayer());
    __publicField(this, "chanceToStay", 0.1);
    __publicField(this, "rotation", new Rotation(0));
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.rotation = new Rotation(Math.random() * 2 * Math.PI);
  }
  onExit() {
    super.onExit();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    this.fsm.getEnemy().getGameObject().setRotation(this.rotation.get());
    const speed = this.fsm.getEnemy().getSpeed();
    const dy = timeElapsed * (Math.sin(this.rotation.get()) * speed);
    const dx = timeElapsed * (Math.cos(this.rotation.get()) * speed);
    const nextBox = this.fsm.getEnemy().getGameObject().getBox().copy();
    nextBox.move(dx, dy);
    const collisions = this.fsm.getEnemy().findCollisions(nextBox);
    if (!collisions.length) {
      this.fsm.getEnemy().getGameObject().getBox().move(dx, dy);
    } else {
      this.fsm.setIdleState();
    }
    if (Random.runChance(timeElapsed / 1e3, this.chanceToStay)) {
      this.fsm.setIdleState();
    }
  }
}
class BaseEnemyDieState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.death);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "unsubscribeFromAnimationEnd", null);
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.unsubscribeFromAnimationEnd = this.animator.onAnimationEndOnce(() => {
      this.fsm.setDeadState();
    });
  }
  onExit() {
    super.onExit();
    if (this.unsubscribeFromAnimationEnd) {
      this.unsubscribeFromAnimationEnd();
    }
  }
  update(timeElapsed) {
    super.update(timeElapsed);
  }
}
class BaseEnemyDeadState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.death);
    __publicField(this, "speed", 0);
    __publicField(this, "fsm");
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
}
class BaseEnemyChasingPlayerState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.run);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createSlimeMovingPlayer());
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
  }
  onEnter() {
    super.onEnter();
    this.player.play();
  }
  onExit() {
    super.onExit();
    this.player.pause();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const currentPlayer = this.fsm.getEnemy().getEntityManager().getEntityByName("player");
    const distance = this.fsm.getEnemy().getGameObject().getBox().getCenter().distance(currentPlayer.getGameObject().getBox().getCenter());
    this.player.tuneSoundByDistance(distance);
    const gameMap = this.fsm.getEnemy().getEntityManager().getEntityByName("map");
    const players = gameMap.findEntities(this.fsm.getEnemy().getGameObject().getBox().getCenter(), this.fsm.getEnemy().getReactDistance()).filter((e) => e instanceof PlayerEntity);
    if (players.length > 0) {
      const playerToChaise = players[0];
      const distanceToPlayer = playerToChaise.getGameObject().getBox().getCenter().distance(this.fsm.getEnemy().getGameObject().getBox().getCenter());
      if (distanceToPlayer > this.fsm.getEnemy().getAttackRange()) {
        const playerCenterPosition = playerToChaise.getGameObject().getBox().getCenter();
        const enemyCenterPosition = this.fsm.getEnemy().getGameObject().getBox().getCenter();
        const angle = playerCenterPosition.getAngle(enemyCenterPosition);
        this.fsm.getEnemy().getGameObject().setRotation(angle);
        const speed = this.fsm.getEnemy().getSpeed();
        const dy = timeElapsed * (Math.sin(angle) * speed);
        const dx = timeElapsed * (Math.cos(angle) * speed);
        const nextBox = this.fsm.getEnemy().getGameObject().getBox().copy();
        nextBox.move(dx, dy);
        if (!this.fsm.getEnemy().findCollisions(nextBox).length) {
          this.fsm.getEnemy().getGameObject().getBox().move(dx, dy);
        }
      } else {
        this.fsm.setAttackState();
      }
    } else {
      this.fsm.setIdleState();
    }
  }
}
class BaseEnemyAttackPlayerState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.attack);
    __publicField(this, "speed", 7);
    __publicField(this, "fsm");
    __publicField(this, "player", MusicPlayer.createEvilSlimePlayer());
    __publicField(this, "enemy");
    this.fsm = fsm;
    this.gameObject = this.fsm.getEnemy().getGameObject();
    this.enemy = this.fsm.getEnemy();
  }
  onEnter() {
    super.onEnter();
    this.player.play();
  }
  onExit() {
    super.onExit();
    this.player.pause();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const currentPlayer = this.fsm.getEnemy().getEntityManager().getEntityByName("player");
    const distance = this.fsm.getEnemy().getGameObject().getBox().getCenter().distance(currentPlayer.getGameObject().getBox().getCenter());
    this.player.tuneSoundByDistance(distance);
    const gameMap = this.fsm.getEnemy().getEntityManager().getEntityByName("map");
    const players = gameMap.findEntities(this.fsm.getEnemy().getGameObject().getBox().getCenter(), this.fsm.getEnemy().getReactDistance()).filter((e) => e instanceof PlayerEntity).filter((player2) => player2.getHealth().getValue() > 0);
    const player = players.length ? players[0] : null;
    if (!player) {
      this.fsm.setIdleState();
    } else {
      const damage = this.enemy.getAttackDamage() * this.enemy.getAttackSpeed() * (timeElapsed / 1e3);
      player.damage(damage);
      if (player.getGameObject().getBox().getCenter().distance(this.fsm.getEnemy().getGameObject().getBox().getCenter()) > this.fsm.getEnemy().getAttackRange()) {
        this.fsm.setChasingPlayerState();
      }
    }
  }
}
class BaseEnemyStateMachine extends FiniteStateMachine {
  constructor(enemy) {
    super();
    __publicField(this, "enemy");
    this.enemy = enemy;
    this.addState("idle", BaseEnemyIdleState);
    this.addState("attack", BaseEnemyIdleState);
    this.addState("die", BaseEnemyDieState);
    this.addState("dead", BaseEnemyDeadState);
    this.addState("hangingAround", BaseEnemyHangingAroundState);
    this.addState("chasingPlayer", BaseEnemyChasingPlayerState);
  }
  setIdleState() {
    this.send({ type: "idle" });
  }
  setHangingAroundState() {
    this.send({ type: "hangingAround" });
  }
  setChasingPlayerState() {
    this.send({ type: "chasingPlayer" });
  }
  setAttackState() {
    this.send({ type: "attack" });
  }
  setDieState() {
    this.send({ type: "die" });
  }
  setDeadState() {
    this.send({ type: "dead" });
  }
  getEnemy() {
    return this.enemy;
  }
  send(action) {
    super.send(action);
    this.setState(this.states[action.type]);
  }
  start() {
    super.start();
    this.setIdleState();
  }
}
class BaseEnemyEntity extends DrawableEntity {
  constructor(x, y) {
    super();
    __publicField(this, "gameObject");
    __publicField(this, "finiteStateMachine");
    __publicField(this, "speed", 0.02);
    __publicField(this, "reactDistance", 300);
    // protected health: Health = new Health(250, 250);
    __publicField(this, "health", new Health(10, 250));
    __publicField(this, "attackSpeed", 5);
    __publicField(this, "attackDamage", 10);
    __publicField(this, "attackRange", 50);
    this.finiteStateMachine = new BaseEnemyStateMachine(this);
    this.gameObject = new BaseEnemyGameObject(x, y, this, this.finiteStateMachine);
  }
  getHealth() {
    return this.health;
  }
  setHealth(value) {
    this.health.setValue(value);
  }
  damage(value, from) {
    let newHealth = this.getHealth().getValue() - value;
    if (newHealth <= 0) {
      newHealth = 0;
      this.emitter.emit(GAME_EVENTS.KILLED_EVENT, { who: this, killer: from });
      this.finiteStateMachine.setDieState();
    }
    this.setHealth(newHealth);
  }
  getAttackSpeed() {
    return this.attackSpeed;
  }
  setAttackSpeed(value) {
    this.attackSpeed = value;
  }
  getAttackDamage() {
    return this.attackDamage;
  }
  setAttackDamage(value) {
    this.attackDamage = value;
  }
  getAttackRange() {
    return this.attackRange;
  }
  setAttackRange(value) {
    this.attackRange = value;
  }
  getReactDistance() {
    return this.reactDistance;
  }
  getSpeed() {
    return this.speed;
  }
  getGameObject() {
    return this.gameObject;
  }
  initEntity() {
    super.initEntity();
    this.finiteStateMachine.start();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    this.finiteStateMachine.update(timeElapsed);
  }
}
class SlimeEnemyIdleState extends BaseEnemyIdleState {
  constructor() {
    super(...arguments);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.idle);
  }
}
class SlimeEnemyHangingAroundState extends BaseEnemyHangingAroundState {
  constructor() {
    super(...arguments);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.move);
  }
}
class SlimeEnemyDieState extends BaseEnemyDieState {
  constructor() {
    super(...arguments);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.die);
  }
}
class SlimeEnemyDeadState extends BaseEnemyDeadState {
  constructor() {
    super(...arguments);
    __publicField(this, "speed", 1);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.die.slice(0, 2));
  }
}
class SlimeEnemyChasingPlayerState extends BaseEnemyChasingPlayerState {
  constructor() {
    super(...arguments);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.move);
  }
}
class SlimeEnemyAttackPlayerState extends BaseEnemyAttackPlayerState {
  constructor() {
    super(...arguments);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().slime.attack);
  }
}
class SlimeStateMachine extends BaseEnemyStateMachine {
  constructor(slimeEnemyEntity) {
    super(slimeEnemyEntity);
    this.addState("idle", SlimeEnemyIdleState);
    this.addState("attack", SlimeEnemyAttackPlayerState);
    this.addState("die", SlimeEnemyDieState);
    this.addState("dead", SlimeEnemyDeadState);
    this.addState("hangingAround", SlimeEnemyHangingAroundState);
    this.addState("chasingPlayer", SlimeEnemyChasingPlayerState);
  }
}
class SlimeGameObject extends BaseEnemyGameObject {
  isRightToLeft() {
    return false;
  }
}
class SlimeEntity extends BaseEnemyEntity {
  constructor(x, y) {
    super(x, y);
    __publicField(this, "health", new Health(250, 250));
    this.finiteStateMachine = new SlimeStateMachine(this);
    this.gameObject = new SlimeGameObject(x, y, this, this.finiteStateMachine);
  }
  getHealth() {
    return this.health;
  }
  setHealth(value) {
    this.health.setValue(value);
  }
}
class FireBurningState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().fireSprite);
    __publicField(this, "speed", 6);
    __publicField(this, "fsm");
    this.fsm = fsm;
    this.gameObject = this.fsm.getFire().getGameObject();
  }
  onEnter() {
    this.speed += 3 * Math.random();
    super.onEnter();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
  }
}
class FireStateMachine extends FiniteStateMachine {
  constructor(fire) {
    super();
    __publicField(this, "fire");
    this.fire = fire;
    this.addState(FireBurningState);
    this.setState(FireBurningState);
  }
  getFire() {
    return this.fire;
  }
}
class FireEntity extends DrawableEntity {
  constructor(x, y, width, height) {
    super();
    __publicField(this, "gameObject");
    __publicField(this, "finiteStateMachine");
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.finiteStateMachine = new FireStateMachine(this);
    this.gameObject = new GameObject(this.finiteStateMachine);
    this.gameObject.setBox(new Box(
      new Position(x, y, 0),
      width,
      height
    ));
  }
  getGameObject() {
    return this.gameObject;
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    this.finiteStateMachine.update(timeElapsed);
  }
}
const TITLE = `Задача. Очистить дом`;
const BODY = `О нет! Наша великая империя находится в упадке! Демоны нападают со всех сторон, культы предателей возникают то тут, то тамНам предстоит сделать выбор - мы герой или революционер. От нас зависит судьба империи - выберем ли мы разрушить её, либо отстроить из пепла и руин.Вы - независимый герой, способный на многое! Перед вами открывается путь приключений доселе не слыханной широты! Доколе мы - простые люди империидолжны страдать от гнёта короля-тирана. Пора навести порядок и восстановить справедливость! <br />  <br /> убейте 3х водных сламов и потушите ваш дом. Тогда империя восстановится.`;
class QuestEntity extends Entity {
  constructor() {
    super();
    __publicField(this, "unsubscribeFromKilledEvent", null);
    __publicField(this, "closeStartModalFn", null);
    __publicField(this, "killCount", 0);
    __publicField(this, "done", false);
    __publicField(this, "fires", []);
  }
  initEntity() {
    super.initEntity();
    const uiEntity = this.getEntityManager().getEntityByName("ui");
    uiEntity.addQuest("initial", TITLE, () => {
      uiEntity.showModal({
        title: TITLE,
        body: BODY
      });
    });
    this.closeStartModalFn = uiEntity.showModal({
      title: TITLE,
      body: BODY
    });
    this.unsubscribeFromKilledEvent = this.getEntityManager().emitter.subscribe(GAME_EVENTS.KILLED_EVENT, ({ who, killer }) => {
      if (!this.done && who instanceof SlimeEntity && killer instanceof PlayerEntity) {
        this.killCount++;
        if (this.killCount === 3) {
          this.done = false;
          this.onSuccess();
        }
      }
    });
    for (let j = 0; j < 5; j++) {
      const fire = new FireEntity(-70, 50 * (j + 1), 150, 150);
      this.getEntityManager().addToScene(fire);
      this.getEntityManager().addEntity(fire);
      this.fires.push(fire);
    }
    for (let j = 0; j < 10; j++) {
      const fire = new FireEntity(j * 50, -70, 150, 150);
      this.getEntityManager().addToScene(fire);
      this.getEntityManager().addEntity(fire);
      this.fires.push(fire);
    }
  }
  onSuccess() {
    if (this.closeStartModalFn) {
      this.closeStartModalFn();
    }
    const uiEntity = this.getEntityManager().getEntityByName("ui");
    uiEntity.markQuestDone("initial");
    uiEntity.showModal({
      title: "Congrats!",
      body: "You have done the quests! Fire is down. Империя спасена! Good shape хороший Color и fabric"
    });
    this.fires.forEach((fire) => {
      this.getEntityManager().removeEntity(fire);
    });
  }
  destroy() {
    super.destroy();
    if (this.unsubscribeFromKilledEvent) {
      this.unsubscribeFromKilledEvent();
    }
  }
}
class UIEntity extends Entity {
  constructor() {
    super(...arguments);
    __publicField(this, "ui", document.getElementById("ui"));
    __publicField(this, "openModals", []);
    __publicField(this, "quests", []);
  }
  addQuest(id, text, onClick) {
    this.quests.push({ id, text, onClick });
    this.renderQuests();
  }
  markQuestDone(id) {
    this.quests.find((q) => q.id === id).done = true;
    this.renderQuests();
  }
  renderQuests() {
    this.ui.querySelector("#quests .quests__list").innerHTML = this.quests.map((quest) => {
      return `
        <div data-quest-id="${quest.id}" class="quest-list-item ${quest.done ? "quest-list-item--done" : ""}"><p>${quest.text}</p></div>
      `;
    }).join("");
    this.quests.forEach((quest) => {
      const questId = quest.id;
      if (!quest.done) {
        this.ui.querySelector(`[data-quest-id="${questId}"]`).onclick = quest.onClick ?? null;
      }
    });
  }
  showModal({ title, body, updater, onClose }) {
    const id = this.createModalId();
    const modal = this.createModal();
    const titleElem = modal.querySelector(".modal__title");
    const bodyElem = modal.querySelector(".modal__body");
    const okButtonElem = modal.querySelector(".modal__okButton");
    titleElem.innerHTML = title;
    bodyElem.innerHTML = body;
    this.openModals.push(id);
    this.ui.appendChild(modal);
    const close = () => {
      const prevLength = this.openModals.length;
      this.openModals = this.openModals.filter((modalId) => modalId !== id);
      const newLength = this.openModals.length;
      if (prevLength !== newLength) {
        this.ui.removeChild(modal);
      }
      onClose == null ? void 0 : onClose();
    };
    okButtonElem.onclick = close;
    if (updater) {
      updater(modal);
    }
    return close;
  }
  createModal() {
    const div = document.createElement("div");
    div.classList.add("modal");
    const title = document.createElement("h1");
    title.classList.add("modal__title");
    div.appendChild(title);
    const body = document.createElement("p");
    body.classList.add("modal__body");
    div.appendChild(body);
    const okButton = document.createElement("div");
    okButton.innerText = "ok";
    okButton.classList.add("modal__okButton");
    okButton.innerHTML = `<button id="start" style="width: 100%; height: 35px" class="gameButton">OK</button>`;
    div.appendChild(okButton);
    return div;
  }
  createModalId() {
    return "modal_id_" + Math.random().toString().replace(".", "");
  }
}
class GuardEnemyIdleState extends BaseEnemyIdleState {
  constructor() {
    super(...arguments);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.idle);
  }
}
class GuardEnemyHangingAroundState extends BaseEnemyHangingAroundState {
  constructor() {
    super(...arguments);
    __publicField(this, "speed", 2);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.run);
  }
}
class GuardEnemyDieState extends BaseEnemyDieState {
  constructor() {
    super(...arguments);
    __publicField(this, "speed", 2);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.death);
  }
}
class GuardEnemyDeadState extends BaseEnemyDeadState {
  constructor() {
    super(...arguments);
    __publicField(this, "speed", 0);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.death);
  }
}
class GuardEnemyChasingPlayerState extends BaseEnemyChasingPlayerState {
  constructor() {
    super(...arguments);
    __publicField(this, "speed", 2);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.run);
  }
}
class GuardEnemyAttackPlayerState extends BaseEnemyAttackPlayerState {
  constructor() {
    super(...arguments);
    __publicField(this, "speed", 2);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().guard.attack);
  }
}
class GuardStateMachine extends BaseEnemyStateMachine {
  constructor(enemy) {
    super(enemy);
    this.addState("idle", GuardEnemyIdleState);
    this.addState("attack", GuardEnemyAttackPlayerState);
    this.addState("die", GuardEnemyDieState);
    this.addState("dead", GuardEnemyDeadState);
    this.addState("hangingAround", GuardEnemyHangingAroundState);
    this.addState("chasingPlayer", GuardEnemyChasingPlayerState);
  }
}
class GuardGameObject extends BaseEnemyGameObject {
}
class GuardEntity extends BaseEnemyEntity {
  constructor(x, y) {
    super(x, y);
    __publicField(this, "health", new Health(100, 100));
    this.finiteStateMachine = new GuardStateMachine(this);
    this.gameObject = new GuardGameObject(x, y, this, this.finiteStateMachine);
  }
  getHealth() {
    return this.health;
  }
  setHealth(value) {
    this.health.setValue(value);
  }
}
class SceneRenderer {
  constructor(width, height, scene, entityManager) {
    __publicField(this, "started", false);
    __publicField(this, "canvas", null);
    __publicField(this, "context", null);
    __publicField(this, "prevDOMHighResTimeStamp", 0);
    this.width = width;
    this.height = height;
    this.scene = scene;
    this.entityManager = entityManager;
  }
  getCanvas() {
    return this.canvas;
  }
  start() {
    if (this.started) {
      return;
    }
    this.started = true;
    if (!this.canvas) {
      this.canvas = this.createCanvas();
      this.context = this.canvas.getContext("2d");
    }
    this.run();
  }
  stop() {
    this.started = false;
  }
  run() {
    if (!this.started) {
      return;
    }
    requestAnimationFrame((timestamp) => {
      var _a;
      const timeElapsed = timestamp - this.prevDOMHighResTimeStamp;
      this.prevDOMHighResTimeStamp = timestamp;
      (_a = this.context) == null ? void 0 : _a.clearRect(0, 0, this.width, this.height);
      this.scene.entities.forEach((entity) => {
        const drawableEntity = entity;
        drawableEntity.getGameObject().draw(this.context, this.scene.camera);
      });
      this.entityManager.update(timeElapsed);
      this.run();
    });
  }
  createCanvas() {
    const canvas2 = document.createElement("canvas");
    canvas2.width = this.width;
    canvas2.height = this.height;
    canvas2.getContext("2d").imageSmoothingEnabled = false;
    return canvas2;
  }
}
class EntityPreview {
  constructor(entity) {
    __publicField(this, "element", null);
    __publicField(this, "sceneRenderer", null);
    __publicField(this, "destroyed", false);
    this.entity = entity;
  }
  mount(id) {
    var _a;
    const WIDTH = 100;
    const HEIGHT = 100;
    this.element = document.getElementById(id);
    const camera = new Camera(WIDTH, HEIGHT);
    const scene = {
      camera,
      entities: []
    };
    const entityManager = new EntityManager(scene);
    scene.entities.push(this.entity);
    entityManager.addEntity(this.entity);
    const sceneRenderer = new SceneRenderer(WIDTH, HEIGHT, scene, entityManager);
    sceneRenderer.start();
    (_a = this.element) == null ? void 0 : _a.appendChild(sceneRenderer.getCanvas());
    this.sceneRenderer = sceneRenderer;
  }
  destroy() {
    if (this.destroyed) {
      console.error("Calling destroy on already destroyed EntityPreview");
      return;
    }
    this.sceneRenderer.stop();
    this.element.removeChild(this.sceneRenderer.getCanvas());
    this.destroyed = true;
  }
}
class DeathIdleState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "sprites", ResourceLoader.getLoadedAssets().deathSprite);
    __publicField(this, "speed", 2);
    __publicField(this, "fsm");
    this.fsm = fsm;
    this.gameObject = this.fsm.getDeath().getGameObject();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
  }
}
class DeathStateMachine extends FiniteStateMachine {
  constructor(death) {
    super();
    __publicField(this, "death");
    this.death = death;
    this.addState("idle", DeathIdleState);
    this.setState(DeathIdleState);
  }
  getDeath() {
    return this.death;
  }
}
class DeathEntity extends DrawableEntity {
  constructor(x, y) {
    super();
    __publicField(this, "gameObject");
    __publicField(this, "finiteStateMachine");
    this.x = x;
    this.y = y;
    this.finiteStateMachine = new DeathStateMachine(this);
    this.gameObject = new GameObject(this.finiteStateMachine);
    this.gameObject.setBox(new Box(
      new Position(x, y, 0),
      100,
      100
    ));
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    this.finiteStateMachine.update(timeElapsed);
  }
}
class NotSetDeathQuestState extends State {
  onEnter() {
    super.onEnter();
  }
  onExit() {
    super.onExit();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
  }
}
class JustTakenDeathQuestState extends State {
  constructor(fsm) {
    super(fsm);
    __publicField(this, "fsm");
    this.fsm = fsm;
  }
  onEnter() {
    super.onEnter();
    const uiEntity = this.fsm.getQuest().getEntityManager().getEntityByName("ui");
    uiEntity.addQuest("death-quest", "Начало истории", () => {
      this.fsm.getQuest().showQuestInfo();
    });
    const updater = (modal) => {
      modal.style.right = "";
      modal.style.left = "100px";
    };
    uiEntity.showModal({
      title: "Начало истории...",
      body: `Путник! Вот ты где. Поспешим, нам срочно надо восстановить империю!`,
      updater,
      onClose() {
        uiEntity.showModal({
          updater,
          title: "Начало истории...",
          body: "Погоди........ Тыже убийца БОГОВ!"
        });
      }
    });
  }
  onExit() {
    super.onExit();
  }
  update(timeElapsed) {
    super.update(timeElapsed);
  }
}
class DeathQuestStateMachine extends FiniteStateMachine {
  constructor(quest) {
    super();
    this.quest = quest;
    this.addState("not-set", NotSetDeathQuestState);
    this.addState("just-taken", JustTakenDeathQuestState);
    this.setState(NotSetDeathQuestState);
  }
  getQuest() {
    return this.quest;
  }
  send(action) {
    if (action.type === "player_near_death") {
      if (this.getCurrentState() instanceof NotSetDeathQuestState) {
        this.setState(JustTakenDeathQuestState);
      }
    }
  }
}
class DeathQuestEntity extends Entity {
  constructor() {
    super();
    __publicField(this, "player");
    __publicField(this, "death");
    __publicField(this, "fsm", new DeathQuestStateMachine(this));
    __publicField(this, "uiEntity");
  }
  showQuestInfo() {
    this.uiEntity.showModal({
      title: "Начало истории",
      body: `
        Путник. Нам предстоит путешествие на восток. Там мы отыщем древний артефакт зла. С его помощью добро победит.
      `
    });
  }
  initEntity() {
    super.initEntity();
    this.uiEntity = this.getEntityManager().getEntityByName("ui");
    this.player = this.getEntityManager().getEntityByName("player");
    this.death = this.getEntityManager().getEntityByName("death");
  }
  update(timeElapsed) {
    super.update(timeElapsed);
    const distanceToPlayer = this.death.distance(this.player);
    if (distanceToPlayer < 150) {
      this.fsm.send({ type: "player_near_death" });
    }
  }
}
const canvasWidth = window.innerWidth;
const canvasHeight = window.innerHeight;
const timeSpeedInput = document.getElementById("timeSpeedInput");
let timeSpeed = 1;
function setTimeSpeed(ts) {
  document.getElementById("timeSpeedValue").innerText = ts.toString();
  timeSpeed = ts;
  timeSpeedInput.value = ts.toString();
}
timeSpeedInput.oninput = (event) => {
  setTimeSpeed(parseFloat(event.target.value));
};
timeSpeedInput.value = timeSpeed.toString();
document.getElementById("resetTimeButton").onclick = () => {
  setTimeSpeed(1);
};
const canvas = document.getElementById("canvas");
const speedInput = document.getElementById("speedInput");
const attackSpeedInput = document.getElementById("attackSpeedInput");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const debug = document.getElementById("debug");
class Game {
  constructor(canvas2, requestAnimationFrame2, cancelAnimationFrame) {
    __publicField(this, "isSetUp", false);
    __publicField(this, "scene");
    __publicField(this, "canvas");
    __publicField(this, "context");
    __publicField(this, "requestAnimationFrame");
    __publicField(this, "cancelAnimationFrame");
    __publicField(this, "entityManager");
    __publicField(this, "interval", -1);
    __publicField(this, "flowersMap", (() => {
      const flowers = [];
      for (let i = -canvasWidth; i < canvasWidth * 2; i++) {
        for (let j = -canvasHeight; j < canvasHeight * 2; j++) {
          if (Math.random() < 25e-6) {
            flowers.push({
              i,
              j
            });
          }
        }
      }
      return flowers;
    })());
    __publicField(this, "i", 0);
    __publicField(this, "fps", 0);
    __publicField(this, "prevDOMHighResTimeStamp", 0);
    this.canvas = canvas2;
    this.context = this.canvas.getContext("2d");
    this.requestAnimationFrame = requestAnimationFrame2;
    this.cancelAnimationFrame = cancelAnimationFrame;
  }
  getIsSetUp() {
    return this.isSetUp;
  }
  tick(timeElapsed) {
    this.entityManager.update(timeElapsed);
  }
  draw(timeElapsed, timeElapsedReal) {
    this.context.imageSmoothingEnabled = false;
    this.context.clearRect(0, 0, canvasWidth, canvasHeight);
    this.context.beginPath();
    this.context.rect(0, 0, canvasWidth, canvasHeight);
    this.context.fillStyle = "#3f4941";
    this.context.fill();
    const camera = this.scene.camera;
    this.context.filter = camera.getFilter();
    this.flowersMap.forEach(({ i: x, j: y }) => {
      const relativePosition = camera.getRelativePosition(new Position(x, y, 0));
      this.context.drawImage(
        ResourceLoader.getLoadedAssets().flower,
        relativePosition.x,
        relativePosition.y,
        20,
        20
      );
    });
    const visibleEntity = this.scene.entities.filter((entity) => {
      return camera.isVisibleDrawableEntity(entity);
    });
    visibleEntity.forEach((entity) => {
      if (entity.getGameObject) {
        entity.getGameObject().draw(this.context, camera);
      }
    });
    if (this.i % 20 === 0) {
      this.fps = Math.round(1e3 / timeElapsedReal);
    }
    this.context.save();
    this.context.fillStyle = "#ffffff";
    this.context.font = "15px sans-serif";
    this.context.fillText(`FPS: ${this.fps}`, 10, 30);
    this.context.fillText("Attack: E, Move: WASD", 10, 50);
    this.context.restore();
  }
  run() {
    if (!MusicPlayer.getIsPlaying()) {
      MusicPlayer.playMainTheme();
    }
    this.i++;
    if (this.i === 1e3) {
      this.i = 0;
    }
    this.interval = this.requestAnimationFrame((timeStamp) => {
      const timeElapsedReal = timeStamp - this.prevDOMHighResTimeStamp;
      const timeElapsed = timeElapsedReal * timeSpeed;
      this.prevDOMHighResTimeStamp = timeStamp;
      this.draw(timeElapsed, timeElapsedReal);
      this.tick(timeElapsed, timeElapsedReal);
      this.run();
    });
  }
  stop() {
    this.cancelAnimationFrame(this.interval);
  }
  async setUp() {
    if (this.isSetUp) {
      console.error("Game is already set up!");
      return;
    }
    this.scene = {
      camera: null,
      entities: []
    };
    this.entityManager = new EntityManager(this.scene);
    const uiEntity = new UIEntity();
    const uiController = new UIController();
    uiEntity.addComponent(uiController);
    this.entityManager.addEntity(uiEntity, "ui");
    const networkEntity = new Entity();
    const networkController = new NetworkController();
    networkEntity.addComponent(networkController);
    this.entityManager.addEntity(networkEntity, "network");
    const map = new GameMap(this.scene);
    this.entityManager.addEntity(map, "map");
    const mapWall = new MapWall(800, 600);
    this.entityManager.addEntity(mapWall, "mapWall");
    this.scene.entities.push(mapWall);
    const bed2 = new BedEntity();
    this.entityManager.addEntity(bed2, "bed");
    this.scene.entities.push(bed2);
    const player = new PlayerEntity(40, 40);
    speedInput.value = player.getSpeed() + "";
    attackSpeedInput.value = player.getAttackSpeed() + "";
    speedInput.oninput = (event) => {
      player.emitter.emit("speed_change", event.target.value);
    };
    attackSpeedInput.oninput = (event) => {
      player.emitter.emit("attack_speed_change", event.target.value);
    };
    const inputController = new InputController();
    player.addComponent(inputController);
    this.entityManager.addEntity(player, "player");
    const camera = new FollowPlayerCamera(canvasWidth, canvasHeight, player);
    this.entityManager.addEntity(camera, "camera");
    this.scene.camera = camera;
    for (let j = -1e3; j < 1e3; j++) {
      if (j % 50 !== 0)
        continue;
      const fire1 = new FireEntity(j, -1e3, 150, 150);
      fire1.getGameObject().setIsCollidable(true);
      this.entityManager.addEntity(fire1);
      this.scene.entities.push(fire1);
      const fire2 = new FireEntity(j, 1e3, 150, 150);
      fire2.getGameObject().setIsCollidable(true);
      this.entityManager.addEntity(fire2);
      this.scene.entities.push(fire2);
      const fire3 = new FireEntity(-1e3, j, 150, 150);
      fire3.getGameObject().setIsCollidable(true);
      this.entityManager.addEntity(fire3);
      this.scene.entities.push(fire3);
      const fire4 = new FireEntity(1e3, j, 150, 150);
      fire4.getGameObject().setIsCollidable(true);
      this.entityManager.addEntity(fire4);
      this.scene.entities.push(fire4);
    }
    for (let j = 0; j < 3; j++) {
      const slime = new SlimeEntity(200 * Math.random() + 200, 200 * Math.random() + 200);
      this.entityManager.addEntity(slime);
      this.scene.entities.push(slime);
    }
    for (let j = 0; j < 3; j++) {
      const guard = new GuardEntity(200 * Math.random() + 600, 200 * Math.random() + 600);
      this.entityManager.addEntity(guard);
      this.scene.entities.push(guard);
    }
    this.scene.entities.push(player);
    const death = new DeathEntity(-800, -200);
    this.scene.entities.push(death);
    this.entityManager.addEntity(death, "death");
    const questEntity = new QuestEntity();
    this.entityManager.addEntity(questEntity, "quests");
    const deathQuest = new DeathQuestEntity();
    this.entityManager.addEntity(deathQuest, "deathQuest");
    this.isSetUp = true;
  }
}
(async () => {
  const loading = document.getElementById("resource-loader");
  const logs = loading.querySelector(".logs");
  let count = ResourceLoader.getResourceCount();
  let loaded = 0;
  ResourceLoader.emitter.subscribe("logs", ({ status, name }) => {
    if (status === "loading") {
      logs.innerHTML += `<p data-name="${name}" style="line-height: 10%;"><span data-status style="font-family: monospace"> <span style="color: yellow">LOADING</span> </span>: ${name}</p>`;
      logs.scrollTo(0, logs.scrollHeight);
    }
    if (status === "loaded") {
      loaded++;
      let percent = Math.floor(loaded / count * 100);
      logs.querySelector(`[data-name="${name}"] [data-status]`).innerHTML = ` <span style="color: lime">DONE&nbsp;&nbsp;&nbsp;</span> `;
      loading.querySelector("[data-percent]").innerHTML = percent.toString();
    }
  });
  await ResourceLoader.loadGameAssets();
  loading.style.display = "none";
  const entityPreview = new EntityPreview(new PlayerEntity(0, 0));
  entityPreview.mount("select-hero");
  const game = new Game(
    canvas,
    window.requestAnimationFrame.bind(window),
    window.cancelAnimationFrame.bind(window)
  );
  const state = document.getElementById("state");
  const startButton = document.getElementById("start");
  const stopButton = document.getElementById("stop");
  state.innerText = "started";
  startButton.onclick = async function() {
    entityPreview.destroy();
    state.innerText = "started";
    state.style.color = "#22ff00";
    if (!game.getIsSetUp()) {
      await game.setUp();
    }
    game.run();
    document.getElementById("start-stop-buttons").style.top = "0px";
    document.getElementById("start-stop-buttons").style.right = "0px";
    startButton.classList.add("none");
    stopButton.classList.remove("none");
    document.getElementById("quests").classList.remove("none");
    document.getElementById("mobile-controls").classList.remove("none");
    document.getElementById("heroes").classList.add("none");
  };
  stopButton.onclick = function() {
    state.innerText = "stopped";
    state.style.color = "#ff0000";
    debug.innerText = "";
    MusicPlayer.pause();
    game.stop();
    startButton.classList.remove("none");
    stopButton.classList.add("none");
  };
  state.innerText = "stopped";
  state.style.color = "#ff0000";
})();
